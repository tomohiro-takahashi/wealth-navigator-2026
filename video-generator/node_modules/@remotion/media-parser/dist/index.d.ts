import type { LogLevel } from './log';
export { MatroskaSegment } from './containers/webm/segments';
export { MatroskaElement } from './containers/webm/segments/all-segments';
export { hasBeenAborted, IsAGifError, IsAnImageError, IsAnUnsupportedAudioTypeError, IsAnUnsupportedFileTypeError, IsAPdfError, MediaParserAbortError, } from './errors';
export type { SamplePosition } from './get-sample-positions';
export { AudioTrack, MediaParserAudioCodec, MediaParserVideoCodec, OtherTrack, Track, VideoTrack, VideoTrackColorParams, } from './get-tracks';
export { MetadataEntry } from './metadata/get-metadata';
export { MediaParserKeyframe, ParseMediaSrc } from './options';
export type { MediaParserEmbeddedImage } from './state/images';
export { downloadAndParseMedia } from './download-and-parse-media';
export type { MediaParserContainer, Options, ParseMediaCallbacks, ParseMediaFields, ParseMediaOnProgress, ParseMediaOptions, ParseMediaProgress, ParseMediaResult, TracksField, } from './options';
export { parseMedia } from './parse-media';
export { AudioOrVideoSample, OnAudioSample, OnAudioTrack, OnVideoSample, OnVideoTrack, } from './webcodec-sample-types';
export { Dimensions } from './get-dimensions';
export { MediaParserLocation } from './get-location';
export type { ReaderInterface } from './readers/reader';
export type { CreateContent, Writer, WriterInterface } from './writers/writer';
export declare const MediaParserInternals: {
    Log: {
        trace: (logLevel: LogLevel, ...args: Parameters<typeof console.log>) => void;
        verbose: (logLevel: LogLevel, ...args: Parameters<typeof console.log>) => void;
        info: (logLevel: LogLevel, ...args: Parameters<typeof console.log>) => void;
        warn: (logLevel: LogLevel, ...args: Parameters<typeof console.log>) => void;
        error: (...args: Parameters<typeof console.log>) => void;
    };
    createAacCodecPrivate: ({ audioObjectType, sampleRate, channelConfiguration, codecPrivate, }: {
        audioObjectType: number;
        sampleRate: number;
        channelConfiguration: number;
        codecPrivate: Uint8Array | null;
    }) => Uint8Array;
    matroskaElements: {
        readonly Header: "0x1a45dfa3";
        readonly EBMLMaxIDLength: "0x42f2";
        readonly EBMLVersion: "0x4286";
        readonly EBMLReadVersion: "0x42f7";
        readonly EBMLMaxSizeLength: "0x42f3";
        readonly DocType: "0x4282";
        readonly DocTypeVersion: "0x4287";
        readonly DocTypeReadVersion: "0x4285";
        readonly Segment: "0x18538067";
        readonly SeekHead: "0x114d9b74";
        readonly Seek: "0x4dbb";
        readonly SeekID: "0x53ab";
        readonly SeekPosition: "0x53ac";
        readonly Info: "0x1549a966";
        readonly SegmentUUID: "0x73a4";
        readonly SegmentFilename: "0x7384";
        readonly PrevUUID: "0x3cb923";
        readonly PrevFilename: "0x3c83ab";
        readonly NextUUID: "0x3eb923";
        readonly NextFilename: "0x3e83bb";
        readonly SegmentFamily: "0x4444";
        readonly ChapterTranslate: "0x6924";
        readonly ChapterTranslateID: "0x69a5";
        readonly ChapterTranslateCodec: "0x69bf";
        readonly ChapterTranslateEditionUID: "0x69fc";
        readonly TimestampScale: "0x2ad7b1";
        readonly Duration: "0x4489";
        readonly DateUTC: "0x4461";
        readonly Title: "0x7ba9";
        readonly MuxingApp: "0x4d80";
        readonly WritingApp: "0x5741";
        readonly Cluster: "0x1f43b675";
        readonly Timestamp: "0xe7";
        readonly SilentTracks: "0x5854";
        readonly SilentTrackNumber: "0x58d7";
        readonly Position: "0xa7";
        readonly PrevSize: "0xab";
        readonly SimpleBlock: "0xa3";
        readonly BlockGroup: "0xa0";
        readonly Block: "0xa1";
        readonly BlockVirtual: "0xa2";
        readonly BlockAdditions: "0x75a1";
        readonly BlockMore: "0xa6";
        readonly BlockAdditional: "0xa5";
        readonly BlockAddID: "0xee";
        readonly BlockDuration: "0x9b";
        readonly ReferencePriority: "0xfa";
        readonly ReferenceBlock: "0xfb";
        readonly ReferenceVirtual: "0xfd";
        readonly CodecState: "0xa4";
        readonly DiscardPadding: "0x75a2";
        readonly Slices: "0x8e";
        readonly TimeSlice: "0xe8";
        readonly LaceNumber: "0xcc";
        readonly FrameNumber: "0xcd";
        readonly BlockAdditionID: "0xcb";
        readonly Delay: "0xce";
        readonly SliceDuration: "0xcf";
        readonly ReferenceFrame: "0xc8";
        readonly ReferenceOffset: "0xc9";
        readonly ReferenceTimestamp: "0xca";
        readonly EncryptedBlock: "0xaf";
        readonly Tracks: "0x1654ae6b";
        readonly TrackEntry: "0xae";
        readonly TrackNumber: "0xd7";
        readonly TrackUID: "0x73c5";
        readonly TrackType: "0x83";
        readonly FlagEnabled: "0xb9";
        readonly FlagDefault: "0x88";
        readonly FlagForced: "0x55aa";
        readonly FlagHearingImpaired: "0x55ab";
        readonly FlagVisualImpaired: "0x55ac";
        readonly FlagTextDescriptions: "0x55ad";
        readonly FlagOriginal: "0x55ae";
        readonly FlagCommentary: "0x55af";
        readonly FlagLacing: "0x9c";
        readonly MinCache: "0x6de7";
        readonly MaxCache: "0x6df8";
        readonly DefaultDuration: "0x23e383";
        readonly DefaultDecodedFieldDuration: "0x234e7a";
        readonly TrackTimestampScale: "0x23314f";
        readonly TrackOffset: "0x537f";
        readonly MaxBlockAdditionID: "0x55ee";
        readonly BlockAdditionMapping: "0x41e4";
        readonly BlockAddIDValue: "0x41f0";
        readonly BlockAddIDName: "0x41a4";
        readonly BlockAddIDType: "0x41e7";
        readonly BlockAddIDExtraData: "0x41ed";
        readonly Name: "0x536e";
        readonly Language: "0x22b59c";
        readonly LanguageBCP47: "0x22b59d";
        readonly CodecID: "0x86";
        readonly CodecPrivate: "0x63a2";
        readonly CodecName: "0x258688";
        readonly AttachmentLink: "0x7446";
        readonly CodecSettings: "0x3a9697";
        readonly CodecInfoURL: "0x3b4040";
        readonly CodecDownloadURL: "0x26b240";
        readonly CodecDecodeAll: "0xaa";
        readonly TrackOverlay: "0x6fab";
        readonly CodecDelay: "0x56aa";
        readonly SeekPreRoll: "0x56bb";
        readonly TrackTranslate: "0x6624";
        readonly TrackTranslateTrackID: "0x66a5";
        readonly TrackTranslateCodec: "0x66bf";
        readonly TrackTranslateEditionUID: "0x66fc";
        readonly Video: "0xe0";
        readonly FlagInterlaced: "0x9a";
        readonly FieldOrder: "0x9d";
        readonly StereoMode: "0x53b8";
        readonly AlphaMode: "0x53c0";
        readonly OldStereoMode: "0x53b9";
        readonly PixelWidth: "0xb0";
        readonly PixelHeight: "0xba";
        readonly PixelCropBottom: "0x54aa";
        readonly PixelCropTop: "0x54bb";
        readonly PixelCropLeft: "0x54cc";
        readonly PixelCropRight: "0x54dd";
        readonly DisplayWidth: "0x54b0";
        readonly DisplayHeight: "0x54ba";
        readonly DisplayUnit: "0x54b2";
        readonly AspectRatioType: "0x54b3";
        readonly UncompressedFourCC: "0x2eb524";
        readonly GammaValue: "0x2fb523";
        readonly FrameRate: "0x2383e3";
        readonly Colour: "0x55b0";
        readonly MatrixCoefficients: "0x55b1";
        readonly BitsPerChannel: "0x55b2";
        readonly ChromaSubsamplingHorz: "0x55b3";
        readonly ChromaSubsamplingVert: "0x55b4";
        readonly CbSubsamplingHorz: "0x55b5";
        readonly CbSubsamplingVert: "0x55b6";
        readonly ChromaSitingHorz: "0x55b7";
        readonly ChromaSitingVert: "0x55b8";
        readonly Range: "0x55b9";
        readonly TransferCharacteristics: "0x55ba";
        readonly Primaries: "0x55bb";
        readonly MaxCLL: "0x55bc";
        readonly MaxFALL: "0x55bd";
        readonly MasteringMetadata: "0x55d0";
        readonly PrimaryRChromaticityX: "0x55d1";
        readonly PrimaryRChromaticityY: "0x55d2";
        readonly PrimaryGChromaticityX: "0x55d3";
        readonly PrimaryGChromaticityY: "0x55d4";
        readonly PrimaryBChromaticityX: "0x55d5";
        readonly PrimaryBChromaticityY: "0x55d6";
        readonly WhitePointChromaticityX: "0x55d7";
        readonly WhitePointChromaticityY: "0x55d8";
        readonly LuminanceMax: "0x55d9";
        readonly LuminanceMin: "0x55da";
        readonly Projection: "0x7670";
        readonly ProjectionType: "0x7671";
        readonly ProjectionPrivate: "0x7672";
        readonly ProjectionPoseYaw: "0x7673";
        readonly ProjectionPosePitch: "0x7674";
        readonly ProjectionPoseRoll: "0x7675";
        readonly Audio: "0xe1";
        readonly SamplingFrequency: "0xb5";
        readonly OutputSamplingFrequency: "0x78b5";
        readonly Channels: "0x9f";
        readonly ChannelPositions: "0x7d7b";
        readonly BitDepth: "0x6264";
        readonly Emphasis: "0x52f1";
        readonly TrackOperation: "0xe2";
        readonly TrackCombinePlanes: "0xe3";
        readonly TrackPlane: "0xe4";
        readonly TrackPlaneUID: "0xe5";
        readonly TrackPlaneType: "0xe6";
        readonly TrackJoinBlocks: "0xe9";
        readonly TrackJoinUID: "0xed";
        readonly TrickTrackUID: "0xc0";
        readonly TrickTrackSegmentUID: "0xc1";
        readonly TrickTrackFlag: "0xc6";
        readonly TrickMasterTrackUID: "0xc7";
        readonly TrickMasterTrackSegmentUID: "0xc4";
        readonly ContentEncodings: "0x6d80";
        readonly ContentEncoding: "0x6240";
        readonly ContentEncodingOrder: "0x5031";
        readonly ContentEncodingScope: "0x5032";
        readonly ContentEncodingType: "0x5033";
        readonly ContentCompression: "0x5034";
        readonly ContentCompAlgo: "0x4254";
        readonly ContentCompSettings: "0x4255";
        readonly ContentEncryption: "0x5035";
        readonly ContentEncAlgo: "0x47e1";
        readonly ContentEncKeyID: "0x47e2";
        readonly ContentEncAESSettings: "0x47e7";
        readonly AESSettingsCipherMode: "0x47e8";
        readonly ContentSignature: "0x47e3";
        readonly ContentSigKeyID: "0x47e4";
        readonly ContentSigAlgo: "0x47e5";
        readonly ContentSigHashAlgo: "0x47e6";
        readonly Cues: "0x1c53bb6b";
        readonly CuePoint: "0xbb";
        readonly CueTime: "0xb3";
        readonly CueTrackPositions: "0xb7";
        readonly CueTrack: "0xf7";
        readonly CueClusterPosition: "0xf1";
        readonly CueRelativePosition: "0xf0";
        readonly CueDuration: "0xb2";
        readonly CueBlockNumber: "0x5378";
        readonly CueCodecState: "0xea";
        readonly CueReference: "0xdb";
        readonly CueRefTime: "0x96";
        readonly CueRefCluster: "0x97";
        readonly CueRefNumber: "0x535f";
        readonly CueRefCodecState: "0xeb";
        readonly Attachments: "0x1941a469";
        readonly AttachedFile: "0x61a7";
        readonly FileDescription: "0x467e";
        readonly FileName: "0x466e";
        readonly FileMediaType: "0x4660";
        readonly FileData: "0x465c";
        readonly FileUID: "0x46ae";
        readonly FileReferral: "0x4675";
        readonly FileUsedStartTime: "0x4661";
        readonly FileUsedEndTime: "0x4662";
        readonly Chapters: "0x1043a770";
        readonly EditionEntry: "0x45b9";
        readonly EditionUID: "0x45bc";
        readonly EditionFlagHidden: "0x45bd";
        readonly EditionFlagDefault: "0x45db";
        readonly EditionFlagOrdered: "0x45dd";
        readonly EditionDisplay: "0x4520";
        readonly EditionString: "0x4521";
        readonly EditionLanguageIETF: "0x45e4";
        readonly ChapterAtom: "0xb6";
        readonly ChapterUID: "0x73c4";
        readonly ChapterStringUID: "0x5654";
        readonly ChapterTimeStart: "0x91";
        readonly ChapterTimeEnd: "0x92";
        readonly ChapterFlagHidden: "0x98";
        readonly ChapterFlagEnabled: "0x4598";
        readonly ChapterSegmentUUID: "0x6e67";
        readonly ChapterSkipType: "0x4588";
        readonly ChapterSegmentEditionUID: "0x6ebc";
        readonly ChapterPhysicalEquiv: "0x63c3";
        readonly ChapterTrack: "0x8f";
        readonly ChapterTrackUID: "0x89";
        readonly ChapterDisplay: "0x80";
        readonly ChapString: "0x85";
        readonly ChapLanguage: "0x437c";
        readonly ChapLanguageBCP47: "0x437d";
        readonly ChapCountry: "0x437e";
        readonly ChapProcess: "0x6944";
        readonly ChapProcessCodecID: "0x6955";
        readonly ChapProcessPrivate: "0x450d";
        readonly ChapProcessCommand: "0x6911";
        readonly ChapProcessTime: "0x6922";
        readonly ChapProcessData: "0x6933";
        readonly Tags: "0x1254c367";
        readonly Tag: "0x7373";
        readonly Targets: "0x63c0";
        readonly TargetTypeValue: "0x68ca";
        readonly TargetType: "0x63ca";
        readonly TagTrackUID: "0x63c5";
        readonly TagEditionUID: "0x63c9";
        readonly TagChapterUID: "0x63c4";
        readonly TagAttachmentUID: "0x63c6";
        readonly SimpleTag: "0x67c8";
        readonly TagName: "0x45a3";
        readonly TagLanguage: "0x447a";
        readonly TagLanguageBCP47: "0x447b";
        readonly TagDefault: "0x4484";
        readonly TagDefaultBogus: "0x44b4";
        readonly TagString: "0x4487";
        readonly TagBinary: "0x4485";
        readonly Void: "0xec";
        readonly Crc32: "0xbf";
    };
    ebmlMap: {
        readonly "0x1a45dfa3": {
            readonly name: "Header";
            readonly type: "children";
        };
        readonly "0x4282": {
            name: "DocType";
            type: "string";
        };
        readonly "0x63c0": {
            readonly name: "Targets";
            readonly type: "children";
        };
        readonly "0x67c8": {
            readonly name: "SimpleTag";
            readonly type: "children";
        };
        readonly "0x45a3": {
            readonly name: "TagName";
            readonly type: "string";
        };
        readonly "0x4487": {
            readonly name: "TagString";
            readonly type: "string";
        };
        readonly "0x4287": {
            name: "DocTypeVersion";
            type: "uint";
        };
        readonly "0x4285": {
            name: "DocTypeReadVersion";
            type: "uint";
        };
        readonly "0x4286": {
            name: "EBMLVersion";
            type: "uint";
        };
        readonly "0x42f7": {
            name: "EBMLReadVersion";
            type: "uint";
        };
        readonly "0x42f2": {
            readonly name: "EBMLMaxIDLength";
            readonly type: "uint";
        };
        readonly "0x42f3": {
            name: "EBMLMaxSizeLength";
            type: "uint";
        };
        readonly "0xec": {
            name: "Void";
            type: "uint8array";
        };
        readonly "0x1c53bb6b": {
            readonly name: "Cues";
            readonly type: "children";
        };
        readonly "0xbb": {
            readonly name: "CuePoint";
            readonly type: "children";
        };
        readonly "0xb3": {
            readonly name: "CueTime";
            readonly type: "uint";
        };
        readonly "0xb7": {
            readonly name: "CueTrackPositions";
            readonly type: "children";
        };
        readonly "0xf1": {
            readonly name: "CueClusterPosition";
            readonly type: "uint";
        };
        readonly "0xf0": {
            readonly name: "CueRelativePosition";
            readonly type: "uint";
        };
        readonly "0x5378": {
            readonly name: "CueBlockNumber";
            readonly type: "uint";
        };
        readonly "0xf7": {
            readonly name: "CueTrack";
            readonly type: "uint";
        };
        readonly "0x4461": {
            readonly name: "DateUTC";
            readonly type: "uint8array";
        };
        readonly "0x23314f": {
            readonly name: "TrackTimestampScale";
            readonly type: "float";
        };
        readonly "0x56aa": {
            readonly name: "CodecDelay";
            readonly type: "uint8array";
        };
        readonly "0x56bb": {
            readonly name: "SeekPreRoll";
            readonly type: "uint8array";
        };
        readonly "0x75a2": {
            readonly name: "DiscardPadding";
            readonly type: "uint8array";
        };
        readonly "0x78b5": {
            readonly name: "OutputSamplingFrequency";
            readonly type: "uint8array";
        };
        readonly "0x258688": {
            readonly name: "CodecName";
            readonly type: "string";
        };
        readonly "0xa7": {
            readonly name: "Position";
            readonly type: "uint8array";
        };
        readonly "0xcf": {
            readonly name: "SliceDuration";
            readonly type: "uint8array";
        };
        readonly "0x63c5": {
            readonly name: "TagTrackUID";
            readonly type: "hex-string";
        };
        readonly "0x114d9b74": {
            readonly name: "SeekHead";
            readonly type: "children";
        };
        readonly "0x4dbb": {
            readonly name: "Seek";
            readonly type: "children";
        };
        readonly "0x53ab": {
            readonly name: "SeekID";
            readonly type: "hex-string";
        };
        readonly "0x536e": {
            readonly name: "Name";
            readonly type: "string";
        };
        readonly "0x6de7": {
            readonly name: "MinCache";
            readonly type: "uint";
        };
        readonly "0x6df8": {
            readonly name: "MaxCache";
            readonly type: "uint";
        };
        readonly "0x53ac": {
            readonly name: "SeekPosition";
            readonly type: "uint";
        };
        readonly "0xbf": {
            readonly name: "Crc32";
            readonly type: "uint8array";
        };
        readonly "0x4d80": {
            readonly name: "MuxingApp";
            readonly type: "string";
        };
        readonly "0x5741": {
            readonly name: "WritingApp";
            readonly type: "string";
        };
        readonly "0x73a4": {
            readonly name: "SegmentUUID";
            readonly type: "string";
        };
        readonly "0x4489": {
            readonly name: "Duration";
            readonly type: "float";
        };
        readonly "0x86": {
            readonly name: "CodecID";
            readonly type: "string";
        };
        readonly "0x83": {
            readonly name: "TrackType";
            readonly type: "uint";
        };
        readonly "0xb0": {
            readonly name: "PixelWidth";
            readonly type: "uint";
        };
        readonly "0xba": {
            readonly name: "PixelHeight";
            readonly type: "uint";
        };
        readonly "0x2ad7b1": {
            readonly name: "TimestampScale";
            readonly type: "uint";
        };
        readonly "0x1549a966": {
            readonly name: "Info";
            readonly type: "children";
        };
        readonly "0x7ba9": {
            readonly name: "Title";
            readonly type: "string";
        };
        readonly "0xb5": {
            readonly name: "SamplingFrequency";
            readonly type: "float";
        };
        readonly "0x9f": {
            readonly name: "Channels";
            readonly type: "uint";
        };
        readonly "0x53c0": {
            readonly name: "AlphaMode";
            readonly type: "uint";
        };
        readonly "0x9a": {
            readonly name: "FlagInterlaced";
            readonly type: "uint";
        };
        readonly "0x6264": {
            readonly name: "BitDepth";
            readonly type: "uint";
        };
        readonly "0x54ba": {
            readonly name: "DisplayHeight";
            readonly type: "uint";
        };
        readonly "0x54b0": {
            readonly name: "DisplayWidth";
            readonly type: "uint";
        };
        readonly "0x54b2": {
            readonly name: "DisplayUnit";
            readonly type: "uint";
        };
        readonly "0x9c": {
            readonly name: "FlagLacing";
            readonly type: "uint";
        };
        readonly "0x1254c367": {
            readonly name: "Tags";
            readonly type: "children";
        };
        readonly "0x7373": {
            readonly name: "Tag";
            readonly type: "children";
        };
        readonly "0xd7": {
            readonly name: "TrackNumber";
            readonly type: "uint";
        };
        readonly "0x73c5": {
            readonly name: "TrackUID";
            readonly type: "hex-string";
        };
        readonly "0x55b0": {
            readonly name: "Colour";
            readonly type: "children";
        };
        readonly "0x22b59c": {
            readonly name: "Language";
            readonly type: "string";
        };
        readonly "0x23e383": {
            readonly name: "DefaultDuration";
            readonly type: "uint";
        };
        readonly "0x63a2": {
            readonly name: "CodecPrivate";
            readonly type: "uint8array";
        };
        readonly "0x9b": {
            readonly name: "BlockDuration";
            readonly type: "uint";
        };
        readonly "0x75a1": {
            readonly name: "BlockAdditions";
            readonly type: "uint8array";
        };
        readonly "0x55ee": {
            readonly name: "MaxBlockAdditionID";
            readonly type: "uint";
        };
        readonly "0xe1": {
            readonly name: "Audio";
            readonly type: "children";
        };
        readonly "0xe0": {
            readonly name: "Video";
            readonly type: "children";
        };
        readonly "0x88": {
            readonly name: "FlagDefault";
            readonly type: "uint";
        };
        readonly "0xfb": {
            readonly name: "ReferenceBlock";
            readonly type: "uint";
        };
        readonly "0xae": {
            readonly name: "TrackEntry";
            readonly type: "children";
        };
        readonly "0xe7": {
            readonly name: "Timestamp";
            readonly type: "uint";
        };
        readonly "0x1654ae6b": {
            readonly name: "Tracks";
            readonly type: "children";
        };
        readonly "0xa1": {
            readonly name: "Block";
            readonly type: "uint8array";
        };
        readonly "0xa3": {
            readonly name: "SimpleBlock";
            readonly type: "uint8array";
        };
        readonly "0xa0": {
            readonly name: "BlockGroup";
            readonly type: "children";
        };
        readonly "0x18538067": {
            readonly name: "Segment";
            readonly type: "children";
        };
        readonly "0x1f43b675": {
            readonly name: "Cluster";
            readonly type: "children";
        };
        readonly "0x55ba": {
            readonly name: "TransferCharacteristics";
            readonly type: "uint";
        };
        readonly "0x55b1": {
            readonly name: "MatrixCoefficients";
            readonly type: "uint";
        };
        readonly "0x55bb": {
            readonly name: "Primaries";
            readonly type: "uint";
        };
        readonly "0x55b9": {
            readonly name: "Range";
            readonly type: "uint";
        };
        readonly "0x55b7": {
            readonly name: "ChromaSitingHorz";
            readonly type: "uint";
        };
        readonly "0x55b8": {
            readonly name: "ChromaSitingVert";
            readonly type: "uint";
        };
    };
    parseTkhd: ({ iterator, offset, size, }: {
        iterator: import("./buffer-iterator").BufferIterator;
        offset: number;
        size: number;
    }) => import("./containers/iso-base-media/tkhd").TkhdBox;
    getArrayBufferIterator: (initialData: Uint8Array, maxBytes: number | null) => {
        startReadingBits: () => void;
        stopReadingBits: () => void;
        skipTo: (offset: number) => void;
        addData: (newData: Uint8Array) => void;
        counter: import("./buffer-iterator").OffsetCounter;
        peekB: (length: number) => void;
        peekD: (length: number) => void;
        getBits: (bits: number) => number;
        bytesRemaining: () => number;
        leb128: () => number;
        removeBytesRead: (force: boolean, mode: import("./options").ParseMediaMode) => {
            bytesRemoved: number;
            removedData: Uint8Array | null;
        };
        discard: (length: number) => void;
        getEightByteNumber: (littleEndian?: boolean) => number;
        getFourByteNumber: () => number;
        getSlice: (amount: number) => Uint8Array;
        getAtom: () => string;
        detectFileType: () => import("./file-types/detect-file-type").FileType;
        getPaddedFourByteNumber: () => number;
        getMatroskaSegmentId: () => string | null;
        getVint: () => number | null;
        getUint8: () => number;
        getEBML: () => number;
        getInt8: () => number;
        getUint16: () => number;
        getUint16Le: () => number;
        getUint24: () => number;
        getInt24: () => number;
        getInt16: () => number;
        getUint32: () => number;
        getUint64: (littleEndian?: boolean) => bigint;
        getInt64: (littleEndian?: boolean) => bigint;
        getFixedPointUnsigned1616Number: () => number;
        getFixedPointSigned1616Number: () => number;
        getFixedPointSigned230Number: () => number;
        getPascalString: () => number[];
        getUint(length: number): number;
        getByteString(length: number, trimTrailingZeroes: boolean): string;
        planBytes: (size: number) => {
            discardRest: () => Uint8Array;
        };
        getFloat64: () => number;
        readUntilNullTerminator: () => string;
        getFloat32: () => number;
        getUint32Le: () => number;
        getInt32Le: () => number;
        getInt32: () => number;
        destroy: () => void;
        startBox: (size: number) => {
            discardRest: () => void;
            expectNoMoreBytes: () => void;
        };
        readExpGolomb: () => number;
        startCheckpoint: () => {
            returnToCheckpoint: () => void;
        };
        getFlacCodecNumber: () => number;
        getSyncSafeInt32: () => number;
    };
    parseStsd: ({ offset, size, state, }: {
        offset: number;
        size: number;
        state: import("./state/parser-state").ParserState;
    }) => Promise<import("./containers/iso-base-media/stsd/stsd").StsdBox>;
    makeParserState: ({ hasAudioTrackHandlers, hasVideoTrackHandlers, controller, fields, onAudioTrack, onVideoTrack, contentLength, logLevel, mode, src, readerInterface, onDiscardedData, }: {
        hasAudioTrackHandlers: boolean;
        hasVideoTrackHandlers: boolean;
        controller: import("./media-parser-controller").MediaParserController;
        fields: import("./options").Options<import("./options").ParseMediaFields>;
        onAudioTrack: import("./webcodec-sample-types").OnAudioTrack | null;
        onVideoTrack: import("./webcodec-sample-types").OnVideoTrack | null;
        contentLength: number;
        logLevel: LogLevel;
        mode: import("./options").ParseMediaMode;
        src: import("./options").ParseMediaSrc;
        readerInterface: import("./readers/reader").ReaderInterface;
        onDiscardedData: import("./options").OnDiscardedData | null;
    }) => {
        onAudioTrack: import("./webcodec-sample-types").OnAudioTrack | null;
        onVideoTrack: import("./webcodec-sample-types").OnVideoTrack | null;
        emittedFields: import("./options").AllOptions<import("./options").ParseMediaFields>;
        fields: Partial<import("./options").AllOptions<import("./options").ParseMediaFields>>;
        slowDurationAndFps: {
            addVideoSample: (videoSample: import("./webcodec-sample-types").AudioOrVideoSample) => void;
            addAudioSample: (audioSample: import("./webcodec-sample-types").AudioOrVideoSample) => void;
            getSlowDurationInSeconds: () => number;
            getFps: () => number;
            getSlowNumberOfFrames: () => number;
            getAudioBitrate: () => number | null;
            getVideoBitrate: () => number | null;
        };
        contentLength: number;
        images: {
            images: import("./state/images").MediaParserEmbeddedImage[];
            addImage: (image: import("./state/images").MediaParserEmbeddedImage) => void;
        };
        videoSection: {
            setVideoSection: (section: {
                start: number;
                size: number;
            }) => void;
            getVideoSection: () => {
                start: number;
                size: number;
            };
            isInVideoSectionState: (iterator: import("./buffer-iterator").BufferIterator) => "no-section-defined" | "in-section" | "outside-section";
        };
        logLevel: "trace" | "verbose" | "info" | "warn" | "error";
        iterator: {
            startReadingBits: () => void;
            stopReadingBits: () => void;
            skipTo: (offset: number) => void;
            addData: (newData: Uint8Array) => void;
            counter: import("./buffer-iterator").OffsetCounter;
            peekB: (length: number) => void;
            peekD: (length: number) => void;
            getBits: (bits: number) => number;
            bytesRemaining: () => number;
            leb128: () => number;
            removeBytesRead: (force: boolean, mode: import("./options").ParseMediaMode) => {
                bytesRemoved: number;
                removedData: Uint8Array | null;
            };
            discard: (length: number) => void;
            getEightByteNumber: (littleEndian?: boolean) => number;
            getFourByteNumber: () => number;
            getSlice: (amount: number) => Uint8Array;
            getAtom: () => string;
            detectFileType: () => import("./file-types/detect-file-type").FileType;
            getPaddedFourByteNumber: () => number;
            getMatroskaSegmentId: () => string | null;
            getVint: () => number | null;
            getUint8: () => number;
            getEBML: () => number;
            getInt8: () => number;
            getUint16: () => number;
            getUint16Le: () => number;
            getUint24: () => number;
            getInt24: () => number;
            getInt16: () => number;
            getUint32: () => number;
            getUint64: (littleEndian?: boolean) => bigint;
            getInt64: (littleEndian?: boolean) => bigint;
            getFixedPointUnsigned1616Number: () => number;
            getFixedPointSigned1616Number: () => number;
            getFixedPointSigned230Number: () => number;
            getPascalString: () => number[];
            getUint(length: number): number;
            getByteString(length: number, trimTrailingZeroes: boolean): string;
            planBytes: (size: number) => {
                discardRest: () => Uint8Array;
            };
            getFloat64: () => number;
            readUntilNullTerminator: () => string;
            getFloat32: () => number;
            getUint32Le: () => number;
            getInt32Le: () => number;
            getInt32: () => number;
            destroy: () => void;
            startBox: (size: number) => {
                discardRest: () => void;
                expectNoMoreBytes: () => void;
            };
            readExpGolomb: () => number;
            startCheckpoint: () => {
                returnToCheckpoint: () => void;
            };
            getFlacCodecNumber: () => number;
            getSyncSafeInt32: () => number;
        };
        controller: import("./media-parser-controller").MediaParserController;
        mode: import("./options").ParseMediaMode;
        eventLoop: {
            eventLoopBreakIfNeeded: () => Promise<void>;
        };
        src: import("./options").ParseMediaSrc;
        readerInterface: import("./readers/reader").ReaderInterface;
        discardReadBytes: (force: boolean) => Promise<void>;
        getStructureOrNull: () => import("./parse-result").Structure | null;
        getStructure: () => import("./parse-result").Structure;
        setStructure: (value: import("./parse-result").Structure) => void;
        getFlacStructure: () => import("./containers/flac/types").FlacStructure;
        getIsoStructure: () => import("./parse-result").IsoBaseMediaStructure;
        getMp3Structure: () => import("./parse-result").Mp3Structure;
        getRiffStructure: () => import("./containers/riff/riff-box").RiffStructure;
        getTsStructure: () => import("./parse-result").TransportStreamStructure;
        getWavStructure: () => import("./containers/wav/types").WavStructure;
        getMatroskaStructure: () => import("./parse-result").MatroskaStructure;
        riff: {
            getAvcProfile: () => import("./state/parser-state").SpsAndPps | null;
            onProfile: (profile: import("./state/parser-state").SpsAndPps) => Promise<void>;
            registerOnAvcProfileCallback: (callback: (profile: import("./state/parser-state").SpsAndPps) => Promise<void>) => void;
            getNextTrackIndex: () => number;
            incrementNextTrackIndex: () => void;
        };
        transportStream: {
            nextPesHeaderStore: {
                setNextPesHeader: (pesHeader: import("./containers/transport-stream/parse-pes").PacketPes) => void;
                getNextPesHeader: () => import("./containers/transport-stream/parse-pes").PacketPes;
            };
            streamBuffers: Map<number, import("./containers/transport-stream/process-stream-buffers").TransportStreamPacketBuffer>;
        };
        webm: {
            onTrackEntrySegment: import("./containers/webm/segments").OnTrackEntrySegment;
            getTrackInfoByNumber: (id: number) => import("./containers/webm/segments/track-entry").TrackInfo;
            setTimestampOffset: (byteOffset: number, timestamp: number) => void;
            getTimestampOffsetForByteOffset: (byteOffset: number) => number | undefined;
            timescale: null;
            getTimescale: () => number;
            setTimescale: (newTimescale: number) => void;
            addSegment: (seg: Omit<import("./state/webm").SegmentSection, "index">) => void;
            addCluster: (cluster: import("./state/webm").ClusterSection) => void;
            isInsideSegment: (iterator: import("./buffer-iterator").BufferIterator) => import("./state/webm").SegmentSection | null;
            isInsideCluster: (iterator: import("./buffer-iterator").BufferIterator) => import("./state/webm").ClusterSection | null;
        };
        iso: {
            flatSamples: {
                getSamples: (mdatStart: number) => import("./state/iso-base-media/cached-sample-positions").FlatSample[] | null;
                setSamples: (mdatStart: number, samples: import("./state/iso-base-media/cached-sample-positions").FlatSample[]) => void;
            };
            moov: {
                setMoovBox: (moov: import("./containers/iso-base-media/moov/moov").MoovBox) => void;
                getMoovBox: () => import("./containers/iso-base-media/moov/moov").MoovBox | null;
            };
        };
        mp3Info: {
            getMp3Info: () => import("./state/mp3").Mp3Info | null;
            setMp3Info: (info: import("./state/mp3").Mp3Info) => void;
        };
        aac: {
            addSample: ({ offset, size }: {
                offset: number;
                size: number;
            }) => {
                offset: number;
                index: number;
                size: number;
            };
            getSamples: () => {
                offset: number;
                index: number;
                size: number;
            }[];
        };
        flac: {
            setBlockingBitStrategy: (strategy: number) => void;
            getBlockingBitStrategy: () => number | undefined;
        };
        callbacks: {
            registerVideoSampleCallback: (id: number, callback: import("./webcodec-sample-types").OnVideoSample | null) => Promise<void>;
            onAudioSample: (trackId: number, audioSample: import("./webcodec-sample-types").AudioOrVideoSample) => Promise<void>;
            getSamplesForTrack: (trackId: number) => number;
            onVideoSample: (trackId: number, videoSample: import("./webcodec-sample-types").AudioOrVideoSample) => Promise<void>;
            canSkipTracksState: {
                canSkipTracks: () => boolean;
            };
            registerAudioSampleCallback: (id: number, callback: import("./webcodec-sample-types").OnAudioSample | null) => Promise<void>;
            tracks: {
                hasAllTracks: () => boolean;
                getIsDone: () => boolean;
                setIsDone: (logLevel: LogLevel) => void;
                addTrack: (track: import("./get-tracks").Track) => void;
                getTracks: () => import("./get-tracks").Track[];
                ensureHasTracksAtEnd: (fields: import("./options").Options<import("./options").ParseMediaFields>) => void;
            };
            audioSampleCallbacks: Record<number, import("./webcodec-sample-types").OnAudioSample>;
            videoSampleCallbacks: Record<number, import("./webcodec-sample-types").OnVideoSample>;
            hasAudioTrackHandlers: boolean;
            hasVideoTrackHandlers: boolean;
        };
        getInternalStats: () => import("./state/parser-state").InternalStats;
        getSkipBytes: () => number;
        increaseSkippedBytes: (bytes: number) => void;
        keyframes: {
            addKeyframe: (keyframe: import("./options").MediaParserKeyframe) => void;
            getKeyframes: () => import("./options").MediaParserKeyframe[];
        };
    };
    processSample: ({ state, }: {
        state: import("./state/parser-state").ParserState;
    }) => Promise<{
        sample: import("./containers/iso-base-media/stsd/samples").Sample | null;
    }>;
    parseFtyp: ({ iterator, size, offset, }: {
        iterator: import("./buffer-iterator").BufferIterator;
        size: number;
        offset: number;
    }) => import("./containers/iso-base-media/ftyp").FtypBox;
    parseEbml: (state: import("./state/parser-state").ParserState) => Promise<import("./containers/webm/parse-ebml").Prettify<import("./containers/webm/segments/all-segments").PossibleEbml>>;
    parseMvhd: ({ iterator, offset, size, }: {
        iterator: import("./buffer-iterator").BufferIterator;
        offset: number;
        size: number;
    }) => import("./containers/iso-base-media/mvhd").MvhdBox;
    internalParseMedia: import("./options").InternalParseMedia;
};
export type { Prettify } from './containers/webm/parse-ebml';
export type { Ebml, EbmlValue, FloatWithSize, MainSegment, PossibleEbml, TrackEntry, UintWithSize, } from './containers/webm/segments/all-segments';
export type { LogLevel };
export { mediaParserController, MediaParserController, } from './media-parser-controller';
export { VERSION } from './version';
