"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.internalParseMedia = void 0;
const emit_available_info_1 = require("./emit-available-info");
const get_fields_from_callbacks_1 = require("./get-fields-from-callbacks");
const has_all_info_1 = require("./has-all-info");
const log_1 = require("./log");
const media_parser_controller_1 = require("./media-parser-controller");
const perform_seek_1 = require("./perform-seek");
const remotion_license_acknowledge_1 = require("./remotion-license-acknowledge");
const run_parse_iteration_1 = require("./run-parse-iteration");
const parser_state_1 = require("./state/parser-state");
const throttled_progress_1 = require("./throttled-progress");
const internalParseMedia = async function ({ src, fields: _fieldsInReturnValue, reader: readerInterface, onAudioTrack, onVideoTrack, controller = (0, media_parser_controller_1.mediaParserController)(), logLevel, onParseProgress: onParseProgressDoNotCallDirectly, progressIntervalInMs, mode, onDiscardedData, onError, acknowledgeRemotionLicense, apiName, ...more }) {
    var _a;
    (0, remotion_license_acknowledge_1.warnIfRemotionLicenseNotAcknowledged)({
        acknowledgeRemotionLicense,
        logLevel,
        apiName,
    });
    const fieldsInReturnValue = _fieldsInReturnValue !== null && _fieldsInReturnValue !== void 0 ? _fieldsInReturnValue : {};
    const fields = (0, get_fields_from_callbacks_1.getFieldsFromCallback)({
        fields: fieldsInReturnValue,
        callbacks: more,
    });
    const { reader: readerInstance, contentLength, name, contentType, supportsContentRange, } = await readerInterface.read({ src, range: null, controller });
    if (contentLength === null) {
        throw new Error('Cannot read media without a content length. This is currently not supported. Ensure the media has a "Content-Length" HTTP header.');
    }
    if (!supportsContentRange) {
        throw new Error('Cannot read media without it supporting the "Content-Range" header. This is currently not supported. Ensure the media supports the "Content-Range" HTTP header.');
    }
    const hasAudioTrackHandlers = Boolean(onAudioTrack);
    const hasVideoTrackHandlers = Boolean(onVideoTrack);
    if (!hasAudioTrackHandlers &&
        !hasVideoTrackHandlers &&
        Object.values(fields).every((v) => !v) &&
        mode === 'query') {
        log_1.Log.warn(logLevel, new Error('Warning - No `fields` and no `on*` callbacks were passed to `parseMedia()`. Specify the data you would like to retrieve.'));
    }
    let timeIterating = 0;
    let timeReadingData = 0;
    let timeSeeking = 0;
    let timeCheckingIfDone = 0;
    let timeFreeingData = 0;
    let errored = null;
    const state = (0, parser_state_1.makeParserState)({
        hasAudioTrackHandlers,
        hasVideoTrackHandlers,
        controller,
        fields,
        onAudioTrack: onAudioTrack !== null && onAudioTrack !== void 0 ? onAudioTrack : null,
        onVideoTrack: onVideoTrack !== null && onVideoTrack !== void 0 ? onVideoTrack : null,
        contentLength,
        logLevel,
        mode,
        readerInterface,
        src,
        onDiscardedData,
    });
    const { iterator } = state;
    let currentReader = readerInstance;
    const returnValue = {};
    const moreFields = more;
    const throttledState = (0, throttled_progress_1.throttledStateUpdate)({
        updateFn: onParseProgressDoNotCallDirectly !== null && onParseProgressDoNotCallDirectly !== void 0 ? onParseProgressDoNotCallDirectly : null,
        everyMilliseconds: progressIntervalInMs !== null && progressIntervalInMs !== void 0 ? progressIntervalInMs : 100,
        controller,
        totalBytes: contentLength,
    });
    const triggerInfoEmit = async () => {
        const availableInfo = (0, has_all_info_1.getAvailableInfo)({
            fieldsToFetch: fields,
            state,
        });
        await (0, emit_available_info_1.emitAvailableInfo)({
            hasInfo: availableInfo,
            callbacks: moreFields,
            fieldsInReturnValue,
            state,
            returnValue,
            name,
            mimeType: contentType,
        });
    };
    const checkIfDone = async () => {
        const startCheck = Date.now();
        const hasAll = (0, has_all_info_1.hasAllInfo)({
            fields,
            state,
        });
        timeCheckingIfDone += Date.now() - startCheck;
        if (hasAll && mode === 'query') {
            log_1.Log.verbose(logLevel, 'Got all info, skipping to the end.');
            state.increaseSkippedBytes(contentLength - state.iterator.counter.getOffset());
            return true;
        }
        if (state.iterator.counter.getOffset() === contentLength) {
            log_1.Log.verbose(logLevel, 'Reached end of file');
            await state.discardReadBytes(true);
            return true;
        }
        if (state.iterator.counter.getOffset() + state.iterator.bytesRemaining() ===
            contentLength &&
            errored) {
            log_1.Log.verbose(logLevel, 'Reached end of file and errorred');
            return true;
        }
        return false;
    };
    await triggerInfoEmit();
    let iterationWithThisOffset = 0;
    while (!(await checkIfDone())) {
        await controller._internals.checkForAbortAndPause();
        const offsetBefore = iterator.counter.getOffset();
        const fetchMoreData = async () => {
            await controller._internals.checkForAbortAndPause();
            const result = await currentReader.reader.read();
            if (result.value) {
                iterator.addData(result.value);
            }
            return result.done;
        };
        const readStart = Date.now();
        while (iterator.bytesRemaining() < 0) {
            const done = await fetchMoreData();
            if (done) {
                break;
            }
        }
        const hasBigBuffer = iterator.bytesRemaining() > 100000;
        if (iterationWithThisOffset > 0 || !hasBigBuffer) {
            await fetchMoreData();
        }
        await state.eventLoop.eventLoopBreakIfNeeded();
        timeReadingData += Date.now() - readStart;
        (_a = throttledState.update) === null || _a === void 0 ? void 0 : _a.call(throttledState, () => ({
            bytes: iterator.counter.getOffset(),
            percentage: contentLength
                ? iterator.counter.getOffset() / contentLength
                : null,
            totalBytes: contentLength,
        }));
        if (!errored) {
            log_1.Log.trace(logLevel, `Continuing parsing of file, currently at position ${iterator.counter.getOffset()}/${contentLength} (0x${iterator.counter.getOffset().toString(16)})`);
            if (iterationWithThisOffset > 300) {
                throw new Error('Infinite loop detected. The parser is not progressing. This is likely a bug in the parser. You can report this at https://remotion.dev/report and we will fix it as soon as possible.');
            }
            try {
                await triggerInfoEmit();
                const start = Date.now();
                await controller._internals.checkForAbortAndPause();
                const skip = await (0, run_parse_iteration_1.runParseIteration)({
                    state,
                    mimeType: contentType,
                    contentLength,
                    name,
                });
                timeIterating += Date.now() - start;
                if (skip !== null) {
                    state.increaseSkippedBytes(skip.skipTo - iterator.counter.getOffset());
                    if (skip.skipTo === contentLength) {
                        log_1.Log.verbose(logLevel, 'Skipped to end of file, not fetching.');
                        break;
                    }
                    const seekStart = Date.now();
                    currentReader = await (0, perform_seek_1.performSeek)({
                        seekTo: skip.skipTo,
                        currentReader,
                        readerInterface,
                        src,
                        state,
                    });
                    timeSeeking += Date.now() - seekStart;
                }
            }
            catch (e) {
                const err = await onError(e);
                if (!err.action) {
                    throw new Error('onError was used but did not return an "action" field. See docs for this API on how to use onError.');
                }
                if (err.action === 'fail') {
                    throw e;
                }
                if (err.action === 'download') {
                    errored = e;
                    log_1.Log.verbose(logLevel, 'Error was handled by onError and deciding to continue.');
                }
            }
            const didProgress = iterator.counter.getOffset() > offsetBefore;
            if (!didProgress) {
                iterationWithThisOffset++;
            }
            else {
                iterationWithThisOffset = 0;
            }
        }
        const timeFreeStart = Date.now();
        await state.discardReadBytes(false);
        timeFreeingData += Date.now() - timeFreeStart;
    }
    log_1.Log.verbose(logLevel, 'Finished parsing file');
    // Force assign
    await (0, emit_available_info_1.emitAvailableInfo)({
        hasInfo: Object.keys(fields).reduce((acc, key) => {
            if (fields === null || fields === void 0 ? void 0 : fields[key]) {
                acc[key] = true;
            }
            return acc;
        }, {}),
        callbacks: moreFields,
        fieldsInReturnValue,
        state,
        returnValue,
        mimeType: contentType,
        name,
    });
    log_1.Log.verbose(logLevel, `Time iterating over file: ${timeIterating}ms`);
    log_1.Log.verbose(logLevel, `Time fetching data: ${timeReadingData}ms`);
    log_1.Log.verbose(logLevel, `Time seeking: ${timeSeeking}ms`);
    log_1.Log.verbose(logLevel, `Time checking if done: ${timeCheckingIfDone}ms`);
    log_1.Log.verbose(logLevel, `Time freeing data: ${timeFreeingData}ms`);
    currentReader.abort();
    iterator === null || iterator === void 0 ? void 0 : iterator.destroy();
    state.callbacks.tracks.ensureHasTracksAtEnd(fields);
    if (errored) {
        throw errored;
    }
    return returnValue;
};
exports.internalParseMedia = internalParseMedia;
