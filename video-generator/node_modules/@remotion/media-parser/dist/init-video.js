"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.initVideo = void 0;
const errors_1 = require("./errors");
const log_1 = require("./log");
const initVideo = ({ state, mimeType, name, contentLength, }) => {
    const fileType = state.iterator.detectFileType();
    if (fileType.type === 'riff') {
        log_1.Log.verbose(state.logLevel, 'Detected RIFF container');
        state.setStructure({
            type: 'riff',
            boxes: [],
        });
        return;
    }
    if (fileType.type === 'iso-base-media') {
        log_1.Log.verbose(state.logLevel, 'Detected ISO Base Media container');
        state.setStructure({
            type: 'iso-base-media',
            boxes: [],
        });
        return;
    }
    if (fileType.type === 'webm') {
        log_1.Log.verbose(state.logLevel, 'Detected Matroska container');
        state.setStructure({
            boxes: [],
            type: 'matroska',
        });
        return;
    }
    if (fileType.type === 'transport-stream') {
        log_1.Log.verbose(state.logLevel, 'Detected MPEG-2 Transport Stream');
        state.setStructure({
            boxes: [],
            type: 'transport-stream',
        });
        return;
    }
    if (fileType.type === 'mp3') {
        log_1.Log.verbose(state.logLevel, 'Detected MP3');
        const structure = {
            boxes: [],
            type: 'mp3',
        };
        state.setStructure(structure);
        return;
    }
    if (fileType.type === 'wav') {
        log_1.Log.verbose(state.logLevel, 'Detected WAV');
        const structure = {
            boxes: [],
            type: 'wav',
        };
        state.setStructure(structure);
        return;
    }
    if (fileType.type === 'flac') {
        log_1.Log.verbose(state.logLevel, 'Detected FLAC');
        const structure = {
            boxes: [],
            type: 'flac',
        };
        state.setStructure(structure);
        return;
    }
    if (fileType.type === 'aac') {
        log_1.Log.verbose(state.logLevel, 'Detected AAC');
        state.setStructure({
            type: 'aac',
            boxes: [],
        });
        return;
    }
    if (fileType.type === 'gif') {
        return Promise.reject(new errors_1.IsAGifError({
            message: 'GIF files are not yet supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    if (fileType.type === 'pdf') {
        return Promise.reject(new errors_1.IsAPdfError({
            message: 'GIF files are not supported',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    if (fileType.type === 'bmp' ||
        fileType.type === 'jpeg' ||
        fileType.type === 'png' ||
        fileType.type === 'webp') {
        return Promise.reject(new errors_1.IsAnImageError({
            message: 'Image files are not supported',
            imageType: fileType.type,
            dimensions: fileType.dimensions,
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    if (fileType.type === 'unknown') {
        return Promise.reject(new errors_1.IsAnUnsupportedFileTypeError({
            message: 'Unknown file format',
            mimeType,
            sizeInBytes: contentLength,
            fileName: name,
        }));
    }
    return Promise.reject(new Error('Unknown video format ' + fileType));
};
exports.initVideo = initVideo;
