"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processFinalStreamBuffers = exports.processStreamBuffer = void 0;
const handle_aac_packet_1 = require("./handle-aac-packet");
const handle_avc_packet_1 = require("./handle-avc-packet");
const traversal_1 = require("./traversal");
const processStreamBuffer = async ({ streamBuffer, state, programId, structure, }) => {
    const stream = (0, traversal_1.getStreamForId)(structure, programId);
    if (!stream) {
        throw new Error('No stream found');
    }
    // 27 = AVC / H.264 Video
    if (stream.streamType === 27) {
        await (0, handle_avc_packet_1.handleAvcPacket)({
            programId,
            streamBuffer,
            state,
            offset: streamBuffer.offset,
        });
    }
    // 15 = AAC / ADTS
    else if (stream.streamType === 15) {
        await (0, handle_aac_packet_1.handleAacPacket)({
            streamBuffer,
            state,
            programId,
            offset: streamBuffer.offset,
        });
    }
    if (!state.callbacks.tracks.hasAllTracks()) {
        const tracksRegistered = state.callbacks.tracks.getTracks().length;
        const { streams } = (0, traversal_1.findProgramMapTableOrThrow)(structure);
        if (streams.length === tracksRegistered) {
            state.callbacks.tracks.setIsDone(state.logLevel);
        }
    }
};
exports.processStreamBuffer = processStreamBuffer;
const processFinalStreamBuffers = async ({ state, structure, }) => {
    for (const [programId, buffer] of state.transportStream.streamBuffers) {
        if (buffer.buffer.byteLength > 0) {
            await (0, exports.processStreamBuffer)({
                streamBuffer: buffer,
                state,
                programId,
                structure,
            });
            state.transportStream.streamBuffers.delete(programId);
        }
    }
};
exports.processFinalStreamBuffers = processFinalStreamBuffers;
