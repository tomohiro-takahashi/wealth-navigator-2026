"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleAvcPacket = exports.MPEG_TIMESCALE = void 0;
const convert_audio_or_video_sample_1 = require("../../convert-audio-or-video-sample");
const register_track_1 = require("../../register-track");
const codec_string_1 = require("../avc/codec-string");
const create_sps_pps_data_1 = require("../avc/create-sps-pps-data");
const interpret_sps_1 = require("../avc/interpret-sps");
const key_1 = require("../avc/key");
const parse_avc_1 = require("../avc/parse-avc");
const sps_and_pps_1 = require("../avc/sps-and-pps");
exports.MPEG_TIMESCALE = 90000;
const handleAvcPacket = async ({ streamBuffer, programId, state, offset, }) => {
    var _a;
    const avc = (0, parse_avc_1.parseAvc)(streamBuffer.buffer);
    const isTrackRegistered = state.callbacks.tracks.getTracks().find((t) => {
        return t.trackId === programId;
    });
    if (!isTrackRegistered) {
        const spsAndPps = (0, sps_and_pps_1.getSpsAndPps)(avc);
        const dimensions = (0, interpret_sps_1.getDimensionsFromSps)(spsAndPps.sps.spsData);
        const sampleAspectRatio = (0, interpret_sps_1.getSampleAspectRatioFromSps)(spsAndPps.sps.spsData);
        const track = {
            rotation: 0,
            trackId: programId,
            type: 'video',
            timescale: exports.MPEG_TIMESCALE,
            codec: (0, codec_string_1.getCodecStringFromSpsAndPps)(spsAndPps.sps),
            codecPrivate: (0, create_sps_pps_data_1.createSpsPpsData)(spsAndPps),
            fps: null,
            codedWidth: dimensions.width,
            codedHeight: dimensions.height,
            height: dimensions.height,
            width: dimensions.width,
            displayAspectWidth: dimensions.width,
            displayAspectHeight: dimensions.height,
            trakBox: null,
            codecWithoutConfig: 'h264',
            description: undefined,
            sampleAspectRatio: {
                denominator: sampleAspectRatio.height,
                numerator: sampleAspectRatio.width,
            },
            color: (0, interpret_sps_1.getVideoColorFromSps)(spsAndPps.sps.spsData),
        };
        await (0, register_track_1.registerTrack)({ track, state, container: 'transport-stream' });
    }
    // sample for webcodecs needs to be in nano seconds
    const sample = {
        cts: streamBuffer.pesHeader.pts,
        dts: (_a = streamBuffer.pesHeader.dts) !== null && _a !== void 0 ? _a : streamBuffer.pesHeader.pts,
        timestamp: streamBuffer.pesHeader.pts,
        duration: undefined,
        data: new Uint8Array(streamBuffer.buffer),
        trackId: programId,
        type: (0, key_1.getKeyFrameOrDeltaFromAvcInfo)(avc),
        offset,
        timescale: exports.MPEG_TIMESCALE,
    };
    await state.callbacks.onVideoSample(programId, (0, convert_audio_or_video_sample_1.convertAudioOrVideoSampleToWebCodecsTimestamps)(sample, exports.MPEG_TIMESCALE));
};
exports.handleAvcPacket = handleAvcPacket;
