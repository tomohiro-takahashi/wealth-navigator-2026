"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseStream = void 0;
const combine_uint8_arrays_1 = require("../../combine-uint8-arrays");
const adts_header_1 = require("./adts-header");
const discard_rest_of_packet_1 = require("./discard-rest-of-packet");
const find_separator_1 = require("./find-separator");
const process_stream_buffers_1 = require("./process-stream-buffers");
const parseAdtsStream = async ({ restOfPacket, transportStreamEntry, state, structure, offset, }) => {
    var _a, _b;
    const { streamBuffers, nextPesHeaderStore: nextPesHeader } = state.transportStream;
    const streamBuffer = streamBuffers.get(transportStreamEntry.pid);
    if (!streamBuffer) {
        streamBuffers.set(transportStreamEntry.pid, {
            buffer: restOfPacket,
            pesHeader: nextPesHeader.getNextPesHeader(),
            offset,
        });
        return;
    }
    const expectedLength = (_b = (_a = (0, adts_header_1.readAdtsHeader)(streamBuffer.buffer)) === null || _a === void 0 ? void 0 : _a.frameLength) !== null && _b !== void 0 ? _b : null;
    const bytesToTake = expectedLength
        ? Math.min(restOfPacket.length, expectedLength - streamBuffer.buffer.byteLength)
        : restOfPacket.length;
    streamBuffer.buffer = (0, combine_uint8_arrays_1.combineUint8Arrays)([
        streamBuffer.buffer,
        restOfPacket.slice(0, bytesToTake),
    ]);
    if (expectedLength === streamBuffer.buffer.byteLength) {
        await (0, process_stream_buffers_1.processStreamBuffer)({
            streamBuffer,
            programId: transportStreamEntry.pid,
            state,
            structure,
        });
        const rest = restOfPacket.slice(bytesToTake);
        streamBuffers.set(transportStreamEntry.pid, {
            buffer: rest,
            pesHeader: nextPesHeader.getNextPesHeader(),
            offset,
        });
    }
};
const parseAvcStream = async ({ restOfPacket, transportStreamEntry, programId, state, structure, offset, }) => {
    const indexOfSeparator = (0, find_separator_1.findNextSeparator)(restOfPacket, transportStreamEntry);
    const { streamBuffers, nextPesHeaderStore: nextPesHeader } = state.transportStream;
    const streamBuffer = streamBuffers.get(transportStreamEntry.pid);
    if (indexOfSeparator === -1) {
        if (streamBuffer) {
            streamBuffer.buffer = (0, combine_uint8_arrays_1.combineUint8Arrays)([
                streamBuffer.buffer,
                restOfPacket,
            ]);
            return;
        }
        streamBuffers.set(programId, {
            pesHeader: nextPesHeader.getNextPesHeader(),
            buffer: restOfPacket,
            offset,
        });
        return;
    }
    if (streamBuffer) {
        const packet = restOfPacket.slice(0, indexOfSeparator);
        streamBuffer.buffer = (0, combine_uint8_arrays_1.combineUint8Arrays)([streamBuffer.buffer, packet]);
        await (0, process_stream_buffers_1.processStreamBuffer)({
            state,
            streamBuffer,
            programId,
            structure,
        });
        const rest = restOfPacket.slice(indexOfSeparator);
        streamBuffers.set(programId, {
            pesHeader: nextPesHeader.getNextPesHeader(),
            buffer: rest,
            offset,
        });
        return;
    }
    if (indexOfSeparator !== 0) {
        throw new Error('No stream buffer found but new separator is not at the beginning');
    }
    streamBuffers.set(programId, {
        pesHeader: nextPesHeader.getNextPesHeader(),
        buffer: restOfPacket.slice(indexOfSeparator),
        offset,
    });
};
const parseStream = ({ transportStreamEntry, state, programId, structure, }) => {
    const { iterator } = state;
    const restOfPacket = (0, discard_rest_of_packet_1.getRestOfPacket)(iterator);
    if (transportStreamEntry.streamType === 27) {
        return parseAvcStream({
            restOfPacket,
            transportStreamEntry,
            state,
            programId,
            structure,
            offset: iterator.counter.getOffset(),
        });
    }
    if (transportStreamEntry.streamType === 15) {
        return parseAdtsStream({
            restOfPacket,
            transportStreamEntry,
            state,
            structure,
            offset: iterator.counter.getOffset(),
        });
    }
    throw new Error(`Unsupported stream type ${transportStreamEntry.streamType}`);
};
exports.parseStream = parseStream;
