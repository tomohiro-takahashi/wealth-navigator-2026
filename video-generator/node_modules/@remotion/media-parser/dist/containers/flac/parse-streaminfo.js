"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseStreamInfo = void 0;
const register_track_1 = require("../../register-track");
const parseStreamInfo = async ({ iterator, state, }) => {
    const counter = iterator.counter.getOffset();
    const minimumBlockSize = iterator.getUint16();
    const maximumBlockSize = iterator.getUint16();
    const minimumFrameSize = iterator.getUint24();
    const maximumFrameSize = iterator.getUint24();
    iterator.startReadingBits();
    const sampleRate = iterator.getBits(20);
    const channels = iterator.getBits(3) + 1;
    const bitsPerSample = iterator.getBits(5);
    const totalSamples = iterator.getBits(36);
    iterator.getBits(128); // md5
    iterator.stopReadingBits();
    const counterNow = iterator.counter.getOffset();
    const size = counterNow - counter;
    iterator.counter.decrement(size);
    const asUint8Array = iterator.getSlice(size);
    const flacStreamInfo = {
        type: 'flac-streaminfo',
        bitsPerSample,
        channels,
        maximumBlockSize,
        maximumFrameSize,
        minimumBlockSize,
        minimumFrameSize,
        sampleRate,
        totalSamples,
    };
    state.getFlacStructure().boxes.push(flacStreamInfo);
    await (0, register_track_1.registerTrack)({
        container: 'flac',
        state,
        track: {
            codec: 'flac',
            type: 'audio',
            description: asUint8Array,
            codecPrivate: asUint8Array,
            codecWithoutConfig: 'flac',
            numberOfChannels: channels,
            sampleRate,
            timescale: 1000000,
            trackId: 0,
            trakBox: null,
        },
    });
    state.callbacks.tracks.setIsDone(state.logLevel);
    return Promise.resolve(null);
};
exports.parseStreamInfo = parseStreamInfo;
