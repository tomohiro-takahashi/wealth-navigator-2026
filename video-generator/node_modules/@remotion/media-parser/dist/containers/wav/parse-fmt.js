"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFmt = void 0;
const register_track_1 = require("../../register-track");
const parseFmt = async ({ state, }) => {
    const { iterator } = state;
    const ckSize = iterator.getUint32Le(); // chunkSize
    const box = iterator.startBox(ckSize);
    const audioFormat = iterator.getUint16Le();
    if (audioFormat !== 1) {
        throw new Error(`Only supporting WAVE with PCM audio format, but got ${audioFormat}`);
    }
    const numberOfChannels = iterator.getUint16Le();
    const sampleRate = iterator.getUint32Le();
    const byteRate = iterator.getUint32Le();
    const blockAlign = iterator.getUint16Le();
    const bitsPerSample = iterator.getUint16Le();
    const format = bitsPerSample === 16
        ? 'pcm-s16'
        : bitsPerSample === 32
            ? 'pcm-s32'
            : bitsPerSample === 24
                ? 'pcm-s24'
                : null;
    if (format === null) {
        throw new Error(`Unsupported bits per sample: ${bitsPerSample}`);
    }
    const wavHeader = {
        bitsPerSample,
        blockAlign,
        byteRate,
        numberOfChannels,
        sampleRate,
        type: 'wav-fmt',
    };
    state.getWavStructure().boxes.push(wavHeader);
    await (0, register_track_1.registerTrack)({
        state,
        track: {
            type: 'audio',
            codec: format,
            codecPrivate: null,
            description: undefined,
            codecWithoutConfig: format,
            numberOfChannels,
            sampleRate,
            timescale: 1000000,
            trackId: 0,
            trakBox: null,
        },
        container: 'wav',
    });
    box.expectNoMoreBytes();
    return Promise.resolve(null);
};
exports.parseFmt = parseFmt;
