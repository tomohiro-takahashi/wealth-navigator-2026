"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseVideoSection = void 0;
const convert_audio_or_video_sample_1 = require("../../convert-audio-or-video-sample");
const parseVideoSection = async ({ state, }) => {
    const { iterator } = state;
    const structure = state.getWavStructure();
    const videoSection = state.videoSection.getVideoSection();
    const maxOffset = videoSection.start + videoSection.size;
    const maxRead = maxOffset - iterator.counter.getOffset();
    const offset = iterator.counter.getOffset();
    const fmtBox = structure.boxes.find((box) => box.type === 'wav-fmt');
    if (!fmtBox) {
        throw new Error('Expected fmt box');
    }
    const secondsToRead = 1;
    const toRead = Math.min(maxRead, fmtBox.sampleRate * fmtBox.blockAlign * secondsToRead);
    const duration = toRead / (fmtBox.sampleRate * fmtBox.blockAlign);
    const timestamp = (offset - videoSection.start) / (fmtBox.sampleRate * fmtBox.blockAlign);
    const data = iterator.getSlice(toRead);
    await state.callbacks.onAudioSample(0, (0, convert_audio_or_video_sample_1.convertAudioOrVideoSampleToWebCodecsTimestamps)({
        cts: timestamp,
        dts: timestamp,
        data,
        duration,
        timestamp,
        trackId: 0,
        type: 'key',
        offset,
        timescale: 1000000,
    }, 1));
    return null;
};
exports.parseVideoSection = parseVideoSection;
