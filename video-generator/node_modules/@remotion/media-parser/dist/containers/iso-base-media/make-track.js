"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeBaseMediaTrack = void 0;
const get_audio_codec_1 = require("../../get-audio-codec");
const get_fps_1 = require("../../get-fps");
const get_sample_aspect_ratio_1 = require("../../get-sample-aspect-ratio");
const get_video_codec_1 = require("../../get-video-codec");
const get_actual_number_of_channels_1 = require("./get-actual-number-of-channels");
const get_video_codec_from_iso_track_1 = require("./get-video-codec-from-iso-track");
const traversal_1 = require("./traversal");
const makeBaseMediaTrack = (trakBox) => {
    var _a, _b, _c, _d;
    const tkhdBox = (0, traversal_1.getTkhdBox)(trakBox);
    const videoDescriptors = (0, traversal_1.getVideoDescriptors)(trakBox);
    const timescaleAndDuration = (0, get_fps_1.getTimescaleAndDuration)(trakBox);
    if (!tkhdBox) {
        throw new Error('Expected tkhd box in trak box');
    }
    if (!timescaleAndDuration) {
        throw new Error('Expected timescale and duration in trak box');
    }
    if ((0, get_fps_1.trakBoxContainsAudio)(trakBox)) {
        const numberOfChannels = (0, get_audio_codec_1.getNumberOfChannelsFromTrak)(trakBox);
        if (numberOfChannels === null) {
            throw new Error('Could not find number of channels');
        }
        const sampleRate = (0, get_audio_codec_1.getSampleRate)(trakBox);
        if (sampleRate === null) {
            throw new Error('Could not find sample rate');
        }
        const { codecString, description } = (0, get_audio_codec_1.getAudioCodecStringFromTrak)(trakBox);
        const codecPrivate = (_b = (_a = (0, get_audio_codec_1.getCodecPrivateFromTrak)(trakBox)) !== null && _a !== void 0 ? _a : description) !== null && _b !== void 0 ? _b : null;
        const codecWithoutConfig = (0, get_audio_codec_1.getAudioCodecFromTrack)(trakBox);
        const actual = (0, get_actual_number_of_channels_1.getActualDecoderParameters)({
            audioCodec: codecWithoutConfig,
            codecPrivate,
            numberOfChannels,
            sampleRate,
        });
        return {
            type: 'audio',
            trackId: tkhdBox.trackId,
            timescale: timescaleAndDuration.timescale,
            codec: codecString,
            numberOfChannels: actual.numberOfChannels,
            sampleRate: actual.sampleRate,
            description: (_c = actual.codecPrivate) !== null && _c !== void 0 ? _c : undefined,
            trakBox,
            codecPrivate: actual.codecPrivate,
            codecWithoutConfig,
        };
    }
    if (!(0, get_fps_1.trakBoxContainsVideo)(trakBox)) {
        return {
            type: 'other',
            trackId: tkhdBox.trackId,
            timescale: timescaleAndDuration.timescale,
            trakBox,
        };
    }
    const videoSample = (0, get_sample_aspect_ratio_1.getStsdVideoConfig)(trakBox);
    if (!videoSample) {
        throw new Error('No video sample');
    }
    const sampleAspectRatio = (0, get_sample_aspect_ratio_1.getSampleAspectRatio)(trakBox);
    const aspectRatioApplied = (0, get_sample_aspect_ratio_1.applyAspectRatios)({
        dimensions: videoSample,
        sampleAspectRatio,
        displayAspectRatio: (0, get_sample_aspect_ratio_1.getDisplayAspectRatio)({
            sampleAspectRatio,
            nativeDimensions: videoSample,
        }),
    });
    const { displayAspectHeight, displayAspectWidth, height, rotation, width } = (0, get_sample_aspect_ratio_1.applyTkhdBox)(aspectRatioApplied, tkhdBox);
    const codec = (0, get_video_codec_1.getVideoCodecString)(trakBox);
    if (!codec) {
        throw new Error('Could not find video codec');
    }
    const privateData = (0, get_video_codec_1.getVideoPrivateData)(trakBox);
    const track = {
        type: 'video',
        trackId: tkhdBox.trackId,
        description: videoDescriptors !== null && videoDescriptors !== void 0 ? videoDescriptors : undefined,
        timescale: timescaleAndDuration.timescale,
        codec,
        sampleAspectRatio: (0, get_sample_aspect_ratio_1.getSampleAspectRatio)(trakBox),
        width,
        height,
        codedWidth: videoSample.width,
        codedHeight: videoSample.height,
        // Repeating those keys because they get picked up by VideoDecoder
        displayAspectWidth,
        displayAspectHeight,
        rotation,
        trakBox,
        codecPrivate: privateData,
        color: (_d = (0, get_video_codec_1.getIsoBmColrConfig)(trakBox)) !== null && _d !== void 0 ? _d : {
            fullRange: null,
            matrixCoefficients: null,
            primaries: null,
            transferCharacteristics: null,
        },
        codecWithoutConfig: (0, get_video_codec_from_iso_track_1.getVideoCodecFromIsoTrak)(trakBox),
        fps: (0, get_fps_1.getFpsFromMp4TrakBox)(trakBox),
    };
    return track;
};
exports.makeBaseMediaTrack = makeBaseMediaTrack;
