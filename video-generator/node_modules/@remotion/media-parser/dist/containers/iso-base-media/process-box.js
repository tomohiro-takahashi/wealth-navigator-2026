"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processBox = void 0;
const log_1 = require("../../log");
const register_track_1 = require("../../register-track");
const esds_1 = require("./esds/esds");
const ftyp_1 = require("./ftyp");
const get_children_1 = require("./get-children");
const make_track_1 = require("./make-track");
const mdhd_1 = require("./mdhd");
const hdlr_1 = require("./meta/hdlr");
const ilst_1 = require("./meta/ilst");
const moov_1 = require("./moov/moov");
const mvhd_1 = require("./mvhd");
const av1c_1 = require("./stsd/av1c");
const avcc_1 = require("./stsd/avcc");
const colr_1 = require("./stsd/colr");
const ctts_1 = require("./stsd/ctts");
const hvcc_1 = require("./stsd/hvcc");
const keys_1 = require("./stsd/keys");
const mebx_1 = require("./stsd/mebx");
const pasp_1 = require("./stsd/pasp");
const stco_1 = require("./stsd/stco");
const stsc_1 = require("./stsd/stsc");
const stsd_1 = require("./stsd/stsd");
const stss_1 = require("./stsd/stss");
const stsz_1 = require("./stsd/stsz");
const stts_1 = require("./stsd/stts");
const tfdt_1 = require("./tfdt");
const tfhd_1 = require("./tfhd");
const tkhd_1 = require("./tkhd");
const trak_1 = require("./trak/trak");
const trun_1 = require("./trun");
const processBox = async (state) => {
    const { iterator } = state;
    const fileOffset = iterator.counter.getOffset();
    const { returnToCheckpoint } = iterator.startCheckpoint();
    const bytesRemaining = iterator.bytesRemaining();
    const startOff = iterator.counter.getOffset();
    const boxSizeRaw = iterator.getFourByteNumber();
    if (boxSizeRaw === 0) {
        return {
            type: 'void-box',
            boxSize: 0,
        };
    }
    // If `boxSize === 1`, the 8 bytes after the box type are the size of the box.
    if ((boxSizeRaw === 1 && iterator.bytesRemaining() < 12) ||
        iterator.bytesRemaining() < 4) {
        iterator.counter.decrement(iterator.counter.getOffset() - fileOffset);
        throw new Error(`Expected box size of ${bytesRemaining}, got ${boxSizeRaw}. Incomplete boxes are not allowed.`);
    }
    const boxType = iterator.getByteString(4, false);
    const boxSize = boxSizeRaw === 1 ? iterator.getEightByteNumber() : boxSizeRaw;
    log_1.Log.trace(state.logLevel, 'Found box', boxType, boxSize);
    const headerLength = iterator.counter.getOffset() - startOff;
    if (boxType === 'mdat') {
        state.videoSection.setVideoSection({
            size: boxSize - headerLength,
            start: iterator.counter.getOffset(),
        });
        return null;
    }
    if (bytesRemaining < boxSize) {
        returnToCheckpoint();
        return null;
    }
    if (boxType === 'ftyp') {
        return (0, ftyp_1.parseFtyp)({ iterator, size: boxSize, offset: fileOffset });
    }
    if (boxType === 'colr') {
        return (0, colr_1.parseColorParameterBox)({
            iterator,
            size: boxSize,
        });
    }
    if (boxType === 'mvhd') {
        return (0, mvhd_1.parseMvhd)({ iterator, offset: fileOffset, size: boxSize });
    }
    if (boxType === 'tkhd') {
        return (0, tkhd_1.parseTkhd)({ iterator, offset: fileOffset, size: boxSize });
    }
    if (boxType === 'trun') {
        return (0, trun_1.parseTrun)({ iterator, offset: fileOffset, size: boxSize });
    }
    if (boxType === 'tfdt') {
        return (0, tfdt_1.parseTfdt)({ iterator, size: boxSize, offset: fileOffset });
    }
    if (boxType === 'stsd') {
        return (0, stsd_1.parseStsd)({
            offset: fileOffset,
            size: boxSize,
            state,
        });
    }
    if (boxType === 'stsz') {
        return (0, stsz_1.parseStsz)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
    }
    if (boxType === 'stco' || boxType === 'co64') {
        return (0, stco_1.parseStco)({
            iterator,
            offset: fileOffset,
            size: boxSize,
            mode64Bit: boxType === 'co64',
        });
    }
    if (boxType === 'pasp') {
        return (0, pasp_1.parsePasp)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
    }
    if (boxType === 'stss') {
        return (0, stss_1.parseStss)({
            iterator,
            offset: fileOffset,
            boxSize,
        });
    }
    if (boxType === 'ctts') {
        return (0, ctts_1.parseCtts)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
    }
    if (boxType === 'stsc') {
        return (0, stsc_1.parseStsc)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
    }
    if (boxType === 'mebx') {
        return (0, mebx_1.parseMebx)({
            offset: fileOffset,
            size: boxSize,
            state,
        });
    }
    if (boxType === 'hdlr') {
        return (0, hdlr_1.parseHdlr)({ iterator, size: boxSize, offset: fileOffset });
    }
    if (boxType === 'keys') {
        return (0, keys_1.parseKeys)({ iterator, size: boxSize, offset: fileOffset });
    }
    if (boxType === 'ilst') {
        return (0, ilst_1.parseIlstBox)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
    }
    if (boxType === 'moov') {
        if (state.callbacks.tracks.hasAllTracks()) {
            iterator.discard(boxSize - 8);
            return null;
        }
        if (state.iso.moov.getMoovBox()) {
            log_1.Log.verbose(state.logLevel, 'Moov box already parsed, skipping');
            iterator.discard(boxSize - 8);
            return null;
        }
        const box = await (0, moov_1.parseMoov)({
            offset: fileOffset,
            size: boxSize,
            state,
        });
        state.callbacks.tracks.setIsDone(state.logLevel);
        return box;
    }
    if (boxType === 'trak') {
        const box = await (0, trak_1.parseTrak)({
            size: boxSize,
            offsetAtStart: fileOffset,
            state,
        });
        const transformedTrack = (0, make_track_1.makeBaseMediaTrack)(box);
        if (transformedTrack) {
            await (0, register_track_1.registerTrack)({
                state,
                track: transformedTrack,
                container: 'mp4',
            });
        }
        return box;
    }
    if (boxType === 'stts') {
        return (0, stts_1.parseStts)({
            data: iterator,
            size: boxSize,
            fileOffset,
        });
    }
    if (boxType === 'avcC') {
        return (0, avcc_1.parseAvcc)({
            data: iterator,
            size: boxSize,
        });
    }
    if (boxType === 'av1C') {
        return (0, av1c_1.parseAv1C)({
            data: iterator,
            size: boxSize,
        });
    }
    if (boxType === 'hvcC') {
        return (0, hvcc_1.parseHvcc)({
            data: iterator,
            size: boxSize,
            offset: fileOffset,
        });
    }
    if (boxType === 'tfhd') {
        return (0, tfhd_1.getTfhd)({
            iterator,
            offset: fileOffset,
            size: boxSize,
        });
    }
    if (boxType === 'mdhd') {
        return (0, mdhd_1.parseMdhd)({
            data: iterator,
            size: boxSize,
            fileOffset,
        });
    }
    if (boxType === 'esds') {
        return (0, esds_1.parseEsds)({
            data: iterator,
            size: boxSize,
            fileOffset,
        });
    }
    if (boxType === 'mdia' ||
        boxType === 'minf' ||
        boxType === 'stbl' ||
        boxType === 'udta' ||
        boxType === 'moof' ||
        boxType === 'dims' ||
        boxType === 'meta' ||
        boxType === 'wave' ||
        boxType === 'traf' ||
        boxType === 'stsb') {
        const children = await (0, get_children_1.getIsoBaseMediaChildren)({
            state,
            size: boxSize - 8,
        });
        return {
            type: 'regular-box',
            boxType,
            boxSize,
            children,
            offset: fileOffset,
        };
    }
    iterator.discard(boxSize - 8);
    return {
        type: 'regular-box',
        boxType,
        boxSize,
        children: [],
        offset: fileOffset,
    };
};
exports.processBox = processBox;
