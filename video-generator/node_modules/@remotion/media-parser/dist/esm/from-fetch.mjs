// src/errors.ts
class IsAGifError extends Error {
  mimeType;
  sizeInBytes;
  fileName;
  constructor({
    message,
    mimeType,
    sizeInBytes,
    fileName
  }) {
    super(message);
    this.fileName = "IsAGifError";
    this.mimeType = mimeType;
    this.sizeInBytes = sizeInBytes;
    this.fileName = fileName;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, IsAGifError);
    }
  }
}

class IsAnImageError extends Error {
  imageType;
  dimensions;
  mimeType;
  sizeInBytes;
  fileName;
  constructor({
    dimensions,
    imageType,
    message,
    mimeType,
    sizeInBytes,
    fileName
  }) {
    super(message);
    this.name = "IsAnImageError";
    this.imageType = imageType;
    this.dimensions = dimensions;
    this.mimeType = mimeType;
    this.sizeInBytes = sizeInBytes;
    this.fileName = fileName;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, IsAnImageError);
    }
  }
}

class IsAPdfError extends Error {
  mimeType;
  sizeInBytes;
  fileName;
  constructor({
    message,
    mimeType,
    sizeInBytes,
    fileName
  }) {
    super(message);
    this.name = "IsAPdfError";
    this.mimeType = mimeType;
    this.sizeInBytes = sizeInBytes;
    this.fileName = fileName;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, IsAPdfError);
    }
  }
}

class IsAnUnsupportedFileTypeError extends Error {
  mimeType;
  sizeInBytes;
  fileName;
  constructor({
    message,
    mimeType,
    sizeInBytes,
    fileName
  }) {
    super(message);
    this.name = "IsAnUnsupportedFileTypeError";
    this.mimeType = mimeType;
    this.sizeInBytes = sizeInBytes;
    this.fileName = fileName;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, IsAnUnsupportedFileTypeError);
    }
  }
}

class IsAnUnsupportedAudioTypeError extends Error {
  mimeType;
  sizeInBytes;
  fileName;
  audioType;
  constructor({
    message,
    mimeType,
    sizeInBytes,
    fileName,
    audioType
  }) {
    super(message);
    this.name = "IsAnUnsupportedAudioTypeError";
    this.mimeType = mimeType;
    this.sizeInBytes = sizeInBytes;
    this.fileName = fileName;
    this.audioType = audioType;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, IsAnUnsupportedAudioTypeError);
    }
  }
}

class MediaParserAbortError extends Error {
  constructor(message) {
    super(message);
    this.name = "MediaParserAbortError";
    this.cause = undefined;
  }
}
var hasBeenAborted = (error) => {
  return error instanceof MediaParserAbortError;
};

// src/readers/from-fetch.ts
function parseContentRange(input) {
  const matches = input.match(/^(\w+) ((\d+)-(\d+)|\*)\/(\d+|\*)$/);
  if (!matches)
    return null;
  const [, unit, , start, end, size] = matches;
  const range = {
    unit,
    start: start != null ? Number(start) : null,
    end: end != null ? Number(end) : null,
    size: size === "*" ? null : Number(size)
  };
  if (range.start === null && range.end === null && range.size === null) {
    return null;
  }
  return range;
}
var validateContentRangeAndDetectIfSupported = (actualRange, parsedContentRange, statusCode) => {
  if (statusCode === 206) {
    return { supportsContentRange: true };
  }
  if (typeof actualRange === "number" && parsedContentRange?.start !== actualRange) {
    if (actualRange === 0) {
      return { supportsContentRange: false };
    }
    throw new Error(`Range header (${actualRange}) does not match content-range header (${parsedContentRange?.start})`);
  }
  if (actualRange !== null && typeof actualRange !== "number" && (parsedContentRange?.start !== actualRange[0] || parsedContentRange?.end !== actualRange[1])) {
    throw new Error(`Range header (${actualRange}) does not match content-range header (${parsedContentRange?.start})`);
  }
  return { supportsContentRange: true };
};
var fetchReader = {
  read: async ({ src, range, controller }) => {
    if (typeof src !== "string") {
      throw new Error("src must be a string when using `fetchReader`");
    }
    const resolvedUrl = typeof window !== "undefined" && typeof window.location !== "undefined" ? new URL(src, window.location.origin).toString() : src;
    if (!resolvedUrl.startsWith("https://") && !resolvedUrl.startsWith("blob:") && !resolvedUrl.startsWith("http://")) {
      return Promise.reject(new Error(resolvedUrl + " is not a URL - needs to start with http:// or https:// or blob:. If you want to read a local file, pass `reader: nodeReader` to parseMedia()."));
    }
    const ownController = new AbortController;
    const cache = typeof navigator !== "undefined" && navigator.userAgent.includes("Cloudflare-Workers") ? undefined : "no-store";
    const actualRange = range === null ? 0 : range;
    const res = await fetch(resolvedUrl, {
      headers: typeof actualRange === "number" ? {
        Range: `bytes=${actualRange}-`
      } : {
        Range: `bytes=${`${actualRange[0]}-${actualRange[1]}`}`
      },
      signal: ownController.signal,
      cache
    });
    const contentRange = res.headers.get("content-range");
    const parsedContentRange = contentRange ? parseContentRange(contentRange) : null;
    const { supportsContentRange } = validateContentRangeAndDetectIfSupported(actualRange, parsedContentRange, res.status);
    controller._internals.signal.addEventListener("abort", () => {
      ownController.abort(new MediaParserAbortError("Aborted by user"));
    }, { once: true });
    if (res.status.toString().startsWith("4") || res.status.toString().startsWith("5")) {
      throw new Error(`Server returned status code ${res.status} for ${src} and range ${actualRange}`);
    }
    if (!res.body) {
      throw new Error("No body");
    }
    const length = res.headers.get("content-length");
    const contentLength = length === null ? null : parseInt(length, 10);
    const contentDisposition = res.headers.get("content-disposition");
    const name = contentDisposition?.match(/filename="([^"]+)"/)?.[1];
    const fallbackName = src.split("/").pop();
    const reader = res.body.getReader();
    if (controller) {
      controller._internals.signal.addEventListener("abort", () => {
        reader.cancel().catch(() => {
        });
      }, { once: true });
    }
    return {
      reader: {
        reader,
        abort: () => {
          ownController.abort();
        }
      },
      contentLength,
      contentType: res.headers.get("content-type"),
      name: name ?? fallbackName,
      supportsContentRange
    };
  },
  getLength: async (src) => {
    if (typeof src !== "string") {
      throw new Error("src must be a string when using `fetchReader`");
    }
    const res = await fetch(src, {
      method: "HEAD"
    });
    if (!res.body) {
      throw new Error("No body");
    }
    const length = res.headers.get("content-length");
    if (!length) {
      throw new Error("No content-length");
    }
    return parseInt(length, 10);
  }
};
export {
  parseContentRange,
  fetchReader
};
