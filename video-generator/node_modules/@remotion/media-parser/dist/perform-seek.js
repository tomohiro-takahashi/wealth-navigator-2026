"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.performSeek = void 0;
const log_1 = require("./log");
const performSeek = async ({ seekTo, state, currentReader, readerInterface, src, }) => {
    const { iterator, logLevel, controller, mode, contentLength } = state;
    if (seekTo <= iterator.counter.getOffset()) {
        throw new Error(`Seeking backwards is not supported. Current position: ${iterator.counter.getOffset()}, seekTo: ${seekTo}`);
    }
    if (seekTo > state.contentLength) {
        throw new Error(`Unexpected seek: ${seekTo} > ${contentLength}`);
    }
    if (iterator.counter.getOffset() + iterator.bytesRemaining() >= seekTo) {
        log_1.Log.verbose(logLevel, `Skipping over video data from position ${iterator.counter.getOffset()} -> ${seekTo}. Data already fetched`);
        iterator.discard(seekTo - iterator.counter.getOffset());
        return currentReader;
    }
    if (mode === 'download') {
        log_1.Log.verbose(logLevel, `Skipping over video data from position ${iterator.counter.getOffset()} -> ${seekTo}. Fetching but not reading all the data inbetween because in download mode`);
        iterator.discard(seekTo - iterator.counter.getOffset());
        return currentReader;
    }
    const time = Date.now();
    log_1.Log.verbose(logLevel, `Skipping over video data from position ${iterator.counter.getOffset()} -> ${seekTo}. Re-reading because this portion is not available`);
    currentReader.abort();
    await (controller === null || controller === void 0 ? void 0 : controller._internals.checkForAbortAndPause());
    const { reader: newReader } = await readerInterface.read({
        src,
        range: seekTo,
        controller,
    });
    iterator.skipTo(seekTo);
    await state.discardReadBytes(true);
    log_1.Log.verbose(logLevel, `Re-reading took ${Date.now() - time}ms. New position: ${iterator.counter.getOffset()}`);
    return newReader;
};
exports.performSeek = performSeek;
