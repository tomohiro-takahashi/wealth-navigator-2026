"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sampleCallback = void 0;
const can_skip_tracks_1 = require("./can-skip-tracks");
const has_tracks_section_1 = require("./has-tracks-section");
const need_samples_for_fields_1 = require("./need-samples-for-fields");
const sampleCallback = ({ controller, hasAudioTrackHandlers, hasVideoTrackHandlers, fields, keyframes, emittedFields, slowDurationAndFpsState, structure, }) => {
    const videoSampleCallbacks = {};
    const audioSampleCallbacks = {};
    const queuedAudioSamples = {};
    const queuedVideoSamples = {};
    const canSkipTracksState = (0, can_skip_tracks_1.makeCanSkipTracksState)({
        hasAudioTrackHandlers,
        fields,
        hasVideoTrackHandlers,
        structure,
    });
    const tracksState = (0, has_tracks_section_1.makeTracksSectionState)(canSkipTracksState);
    const samplesForTrack = {};
    return {
        registerVideoSampleCallback: async (id, callback) => {
            var _a;
            if (callback === null) {
                delete videoSampleCallbacks[id];
                return;
            }
            videoSampleCallbacks[id] = callback;
            for (const queued of (_a = queuedVideoSamples[id]) !== null && _a !== void 0 ? _a : []) {
                await callback(queued);
            }
            queuedVideoSamples[id] = [];
        },
        onAudioSample: async (trackId, audioSample) => {
            if (controller._internals.signal.aborted) {
                throw new Error('Aborted');
            }
            if (typeof samplesForTrack[trackId] === 'undefined') {
                samplesForTrack[trackId] = 0;
            }
            const callback = audioSampleCallbacks[trackId];
            if (audioSample.data.length > 0) {
                samplesForTrack[trackId]++;
                // If we emit samples with data length 0, Chrome will fail
                if (callback) {
                    await callback(audioSample);
                }
            }
            if ((0, need_samples_for_fields_1.needsToIterateOverSamples)({ emittedFields, fields })) {
                slowDurationAndFpsState.addAudioSample(audioSample);
            }
        },
        getSamplesForTrack: (trackId) => {
            var _a;
            return (_a = samplesForTrack[trackId]) !== null && _a !== void 0 ? _a : 0;
        },
        onVideoSample: async (trackId, videoSample) => {
            if (controller._internals.signal.aborted) {
                throw new Error('Aborted');
            }
            if (typeof samplesForTrack[trackId] === 'undefined') {
                samplesForTrack[trackId] = 0;
            }
            if (videoSample.data.length > 0) {
                samplesForTrack[trackId]++;
                const callback = videoSampleCallbacks[trackId];
                // If we emit samples with data 0, Chrome will fail
                if (callback) {
                    await callback(videoSample);
                }
            }
            if ((0, need_samples_for_fields_1.needsToIterateOverSamples)({
                fields,
                emittedFields,
            })) {
                if (fields.slowKeyframes && videoSample.type === 'key') {
                    keyframes.addKeyframe({
                        trackId,
                        decodingTimeInSeconds: videoSample.dts / videoSample.timescale,
                        positionInBytes: videoSample.offset,
                        presentationTimeInSeconds: videoSample.cts / videoSample.timescale,
                        sizeInBytes: videoSample.data.length,
                    });
                }
                slowDurationAndFpsState.addVideoSample(videoSample);
            }
        },
        canSkipTracksState,
        registerAudioSampleCallback: async (id, callback) => {
            var _a;
            if (callback === null) {
                delete audioSampleCallbacks[id];
                return;
            }
            audioSampleCallbacks[id] = callback;
            for (const queued of (_a = queuedAudioSamples[id]) !== null && _a !== void 0 ? _a : []) {
                await callback(queued);
            }
            queuedAudioSamples[id] = [];
        },
        tracks: tracksState,
        audioSampleCallbacks,
        videoSampleCallbacks,
        hasAudioTrackHandlers,
        hasVideoTrackHandlers,
    };
};
exports.sampleCallback = sampleCallback;
