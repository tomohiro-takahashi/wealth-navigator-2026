import { type BufferIterator } from '../buffer-iterator';
import type { AvcPPs, AvcProfileInfo } from '../containers/avc/parse-avc';
import { type LogLevel } from '../log';
import type { MediaParserController } from '../media-parser-controller';
import type { OnDiscardedData, Options, ParseMediaFields, ParseMediaMode, ParseMediaSrc } from '../options';
import type { ReaderInterface } from '../readers/reader';
import type { OnAudioTrack, OnVideoTrack } from '../webcodec-sample-types';
export type InternalStats = {
    skippedBytes: number;
    finalCursorOffset: number;
};
export type SpsAndPps = {
    sps: AvcProfileInfo;
    pps: AvcPPs;
};
export declare const makeParserState: ({ hasAudioTrackHandlers, hasVideoTrackHandlers, controller, fields, onAudioTrack, onVideoTrack, contentLength, logLevel, mode, src, readerInterface, onDiscardedData, }: {
    hasAudioTrackHandlers: boolean;
    hasVideoTrackHandlers: boolean;
    controller: MediaParserController;
    fields: Options<ParseMediaFields>;
    onAudioTrack: OnAudioTrack | null;
    onVideoTrack: OnVideoTrack | null;
    contentLength: number;
    logLevel: LogLevel;
    mode: ParseMediaMode;
    src: ParseMediaSrc;
    readerInterface: ReaderInterface;
    onDiscardedData: OnDiscardedData | null;
}) => {
    onAudioTrack: OnAudioTrack | null;
    onVideoTrack: OnVideoTrack | null;
    emittedFields: import("../options").AllOptions<ParseMediaFields>;
    fields: Partial<import("../options").AllOptions<ParseMediaFields>>;
    slowDurationAndFps: {
        addVideoSample: (videoSample: import("../webcodec-sample-types").AudioOrVideoSample) => void;
        addAudioSample: (audioSample: import("../webcodec-sample-types").AudioOrVideoSample) => void;
        getSlowDurationInSeconds: () => number;
        getFps: () => number;
        getSlowNumberOfFrames: () => number;
        getAudioBitrate: () => number | null;
        getVideoBitrate: () => number | null;
    };
    contentLength: number;
    images: {
        images: import("./images").MediaParserEmbeddedImage[];
        addImage: (image: import("./images").MediaParserEmbeddedImage) => void;
    };
    videoSection: {
        setVideoSection: (section: {
            start: number;
            size: number;
        }) => void;
        getVideoSection: () => {
            start: number;
            size: number;
        };
        isInVideoSectionState: (iterator: BufferIterator) => "no-section-defined" | "in-section" | "outside-section";
    };
    logLevel: "trace" | "verbose" | "info" | "warn" | "error";
    iterator: {
        startReadingBits: () => void;
        stopReadingBits: () => void;
        skipTo: (offset: number) => void;
        addData: (newData: Uint8Array) => void;
        counter: import("../buffer-iterator").OffsetCounter;
        peekB: (length: number) => void;
        peekD: (length: number) => void;
        getBits: (bits: number) => number;
        bytesRemaining: () => number;
        leb128: () => number;
        removeBytesRead: (force: boolean, mode: ParseMediaMode) => {
            bytesRemoved: number;
            removedData: Uint8Array | null;
        };
        discard: (length: number) => void;
        getEightByteNumber: (littleEndian?: boolean) => number;
        getFourByteNumber: () => number;
        getSlice: (amount: number) => Uint8Array;
        getAtom: () => string;
        detectFileType: () => import("../file-types/detect-file-type").FileType;
        getPaddedFourByteNumber: () => number;
        getMatroskaSegmentId: () => string | null;
        getVint: () => number | null;
        getUint8: () => number;
        getEBML: () => number;
        getInt8: () => number;
        getUint16: () => number;
        getUint16Le: () => number;
        getUint24: () => number;
        getInt24: () => number;
        getInt16: () => number;
        getUint32: () => number;
        getUint64: (littleEndian?: boolean) => bigint;
        getInt64: (littleEndian?: boolean) => bigint;
        getFixedPointUnsigned1616Number: () => number;
        getFixedPointSigned1616Number: () => number;
        getFixedPointSigned230Number: () => number;
        getPascalString: () => number[];
        getUint(length: number): number;
        getByteString(length: number, trimTrailingZeroes: boolean): string;
        planBytes: (size: number) => {
            discardRest: () => Uint8Array;
        };
        getFloat64: () => number;
        readUntilNullTerminator: () => string;
        getFloat32: () => number;
        getUint32Le: () => number;
        getInt32Le: () => number;
        getInt32: () => number;
        destroy: () => void;
        startBox: (size: number) => {
            discardRest: () => void;
            expectNoMoreBytes: () => void;
        };
        readExpGolomb: () => number;
        startCheckpoint: () => {
            returnToCheckpoint: () => void;
        };
        getFlacCodecNumber: () => number;
        getSyncSafeInt32: () => number;
    };
    controller: MediaParserController;
    mode: ParseMediaMode;
    eventLoop: {
        eventLoopBreakIfNeeded: () => Promise<void>;
    };
    src: ParseMediaSrc;
    readerInterface: ReaderInterface;
    discardReadBytes: (force: boolean) => Promise<void>;
    getStructureOrNull: () => import("../parse-result").Structure | null;
    getStructure: () => import("../parse-result").Structure;
    setStructure: (value: import("../parse-result").Structure) => void;
    getFlacStructure: () => import("../containers/flac/types").FlacStructure;
    getIsoStructure: () => import("../parse-result").IsoBaseMediaStructure;
    getMp3Structure: () => import("../parse-result").Mp3Structure;
    getRiffStructure: () => import("../containers/riff/riff-box").RiffStructure;
    getTsStructure: () => import("../parse-result").TransportStreamStructure;
    getWavStructure: () => import("../containers/wav/types").WavStructure;
    getMatroskaStructure: () => import("../parse-result").MatroskaStructure;
    riff: {
        getAvcProfile: () => SpsAndPps | null;
        onProfile: (profile: SpsAndPps) => Promise<void>;
        registerOnAvcProfileCallback: (callback: (profile: SpsAndPps) => Promise<void>) => void;
        getNextTrackIndex: () => number;
        incrementNextTrackIndex: () => void;
    };
    transportStream: {
        nextPesHeaderStore: {
            setNextPesHeader: (pesHeader: import("../containers/transport-stream/parse-pes").PacketPes) => void;
            getNextPesHeader: () => import("../containers/transport-stream/parse-pes").PacketPes;
        };
        streamBuffers: Map<number, import("../containers/transport-stream/process-stream-buffers").TransportStreamPacketBuffer>;
    };
    webm: {
        onTrackEntrySegment: import("../containers/webm/segments").OnTrackEntrySegment;
        getTrackInfoByNumber: (id: number) => import("../containers/webm/segments/track-entry").TrackInfo;
        setTimestampOffset: (byteOffset: number, timestamp: number) => void;
        getTimestampOffsetForByteOffset: (byteOffset: number) => number | undefined;
        timescale: null;
        getTimescale: () => number;
        setTimescale: (newTimescale: number) => void;
        addSegment: (seg: Omit<import("./webm").SegmentSection, "index">) => void;
        addCluster: (cluster: import("./webm").ClusterSection) => void;
        isInsideSegment: (iterator: BufferIterator) => import("./webm").SegmentSection | null;
        isInsideCluster: (iterator: BufferIterator) => import("./webm").ClusterSection | null;
    };
    iso: {
        flatSamples: {
            getSamples: (mdatStart: number) => import("./iso-base-media/cached-sample-positions").FlatSample[] | null;
            setSamples: (mdatStart: number, samples: import("./iso-base-media/cached-sample-positions").FlatSample[]) => void;
        };
        moov: {
            setMoovBox: (moov: import("../containers/iso-base-media/moov/moov").MoovBox) => void;
            getMoovBox: () => import("../containers/iso-base-media/moov/moov").MoovBox | null;
        };
    };
    mp3Info: {
        getMp3Info: () => import("./mp3").Mp3Info | null;
        setMp3Info: (info: import("./mp3").Mp3Info) => void;
    };
    aac: {
        addSample: ({ offset, size }: {
            offset: number;
            size: number;
        }) => {
            offset: number;
            index: number;
            size: number;
        };
        getSamples: () => {
            offset: number;
            index: number;
            size: number;
        }[];
    };
    flac: {
        setBlockingBitStrategy: (strategy: number) => void;
        getBlockingBitStrategy: () => number | undefined;
    };
    callbacks: {
        registerVideoSampleCallback: (id: number, callback: import("../webcodec-sample-types").OnVideoSample | null) => Promise<void>;
        onAudioSample: (trackId: number, audioSample: import("../webcodec-sample-types").AudioOrVideoSample) => Promise<void>;
        getSamplesForTrack: (trackId: number) => number;
        onVideoSample: (trackId: number, videoSample: import("../webcodec-sample-types").AudioOrVideoSample) => Promise<void>;
        canSkipTracksState: {
            canSkipTracks: () => boolean;
        };
        registerAudioSampleCallback: (id: number, callback: import("../webcodec-sample-types").OnAudioSample | null) => Promise<void>;
        tracks: {
            hasAllTracks: () => boolean;
            getIsDone: () => boolean;
            setIsDone: (logLevel: LogLevel) => void;
            addTrack: (track: import("..").Track) => void;
            getTracks: () => import("..").Track[];
            ensureHasTracksAtEnd: (fields: Options<ParseMediaFields>) => void;
        };
        audioSampleCallbacks: Record<number, import("../webcodec-sample-types").OnAudioSample>;
        videoSampleCallbacks: Record<number, import("../webcodec-sample-types").OnVideoSample>;
        hasAudioTrackHandlers: boolean;
        hasVideoTrackHandlers: boolean;
    };
    getInternalStats: () => InternalStats;
    getSkipBytes: () => number;
    increaseSkippedBytes: (bytes: number) => void;
    keyframes: {
        addKeyframe: (keyframe: import("../options").MediaParserKeyframe) => void;
        getKeyframes: () => import("../options").MediaParserKeyframe[];
    };
};
export type ParserState = ReturnType<typeof makeParserState>;
