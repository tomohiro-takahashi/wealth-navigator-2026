"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.webmState = void 0;
const traversal_1 = require("../containers/webm/traversal");
const webmState = () => {
    const trackEntries = {};
    const onTrackEntrySegment = (trackEntry) => {
        var _a;
        const trackId = (0, traversal_1.getTrackId)(trackEntry);
        if (!trackId) {
            throw new Error('Expected track id');
        }
        if (trackEntries[trackId]) {
            return;
        }
        const codec = (0, traversal_1.getTrackCodec)(trackEntry);
        if (!codec) {
            throw new Error('Expected codec');
        }
        const trackTimescale = (0, traversal_1.getTrackTimestampScale)(trackEntry);
        trackEntries[trackId] = {
            codec: codec.value,
            trackTimescale: (_a = trackTimescale === null || trackTimescale === void 0 ? void 0 : trackTimescale.value) !== null && _a !== void 0 ? _a : null,
        };
    };
    const timestampMap = new Map();
    const getTimestampOffsetForByteOffset = (byteOffset) => {
        const entries = Array.from(timestampMap.entries());
        const sortedByByteOffset = entries
            .sort((a, b) => {
            return a[0] - b[0];
        })
            .reverse();
        for (const [offset, timestamp] of sortedByByteOffset) {
            if (offset >= byteOffset) {
                continue;
            }
            return timestamp;
        }
        return timestampMap.get(byteOffset);
    };
    const setTimestampOffset = (byteOffset, timestamp) => {
        timestampMap.set(byteOffset, timestamp);
    };
    let timescale = null;
    const setTimescale = (newTimescale) => {
        timescale = newTimescale;
    };
    const getTimescale = () => {
        // https://www.matroska.org/technical/notes.html
        // When using the default value of TimestampScale of â€œ1,000,000â€, one Segment Tick represents one millisecond.
        if (timescale === null) {
            return 1000000;
        }
        return timescale;
    };
    const segments = [];
    const clusters = [];
    return {
        onTrackEntrySegment,
        getTrackInfoByNumber: (id) => trackEntries[id],
        setTimestampOffset,
        getTimestampOffsetForByteOffset,
        timescale,
        getTimescale,
        setTimescale,
        addSegment: (seg) => {
            const segment = {
                ...seg,
                index: segments.length,
            };
            segments.push(segment);
        },
        addCluster: (cluster) => {
            clusters.push(cluster);
        },
        isInsideSegment: (iterator) => {
            var _a;
            const offset = iterator.counter.getOffset();
            const insideClusters = segments.filter((cluster) => {
                return (offset >= cluster.start && offset <= cluster.start + cluster.size);
            });
            if (insideClusters.length > 1) {
                throw new Error('Expected to only be inside 1 cluster');
            }
            return (_a = insideClusters[0]) !== null && _a !== void 0 ? _a : null;
        },
        isInsideCluster: (iterator) => {
            for (const cluster of clusters) {
                const offset = iterator.counter.getOffset();
                if (offset >= cluster.start && offset <= cluster.start + cluster.size) {
                    return cluster;
                }
            }
            return null;
        },
    };
};
exports.webmState = webmState;
