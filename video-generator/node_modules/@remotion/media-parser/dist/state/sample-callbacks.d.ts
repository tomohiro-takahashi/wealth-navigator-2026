import type { MediaParserController } from '../media-parser-controller';
import type { AllOptions, Options, ParseMediaFields } from '../options';
import type { AudioOrVideoSample, OnAudioSample, OnVideoSample } from '../webcodec-sample-types';
import { type KeyframesState } from './keyframes';
import type { SlowDurationAndFpsState } from './slow-duration-fps';
import type { StructureState } from './structure';
export declare const sampleCallback: ({ controller, hasAudioTrackHandlers, hasVideoTrackHandlers, fields, keyframes, emittedFields, slowDurationAndFpsState, structure, }: {
    controller: MediaParserController;
    hasAudioTrackHandlers: boolean;
    hasVideoTrackHandlers: boolean;
    fields: Options<ParseMediaFields>;
    keyframes: KeyframesState;
    emittedFields: AllOptions<ParseMediaFields>;
    slowDurationAndFpsState: SlowDurationAndFpsState;
    structure: StructureState;
}) => {
    registerVideoSampleCallback: (id: number, callback: OnVideoSample | null) => Promise<void>;
    onAudioSample: (trackId: number, audioSample: AudioOrVideoSample) => Promise<void>;
    getSamplesForTrack: (trackId: number) => number;
    onVideoSample: (trackId: number, videoSample: AudioOrVideoSample) => Promise<void>;
    canSkipTracksState: {
        canSkipTracks: () => boolean;
    };
    registerAudioSampleCallback: (id: number, callback: OnAudioSample | null) => Promise<void>;
    tracks: {
        hasAllTracks: () => boolean;
        getIsDone: () => boolean;
        setIsDone: (logLevel: import("..").LogLevel) => void;
        addTrack: (track: import("..").Track) => void;
        getTracks: () => import("..").Track[];
        ensureHasTracksAtEnd: (fields: Options<ParseMediaFields>) => void;
    };
    audioSampleCallbacks: Record<number, OnAudioSample>;
    videoSampleCallbacks: Record<number, OnVideoSample>;
    hasAudioTrackHandlers: boolean;
    hasVideoTrackHandlers: boolean;
};
